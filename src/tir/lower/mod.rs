use anyhow::{bail, Result};
use pyo3::prelude::*;
use pyo3::types::{PyList, PyModule};
use std::collections::HashMap;
use std::path::Path;

use super::{
    builtin, ArithBinOp, BitwiseBinOp, CastKind, CmpOp, RawBinOp, TirExpr, TirExprKind,
    TirFunction, TirModule, TirStmt, UnaryOpKind, ValueType,
};
use crate::ast::{ClassInfo, Type};
use crate::errors::{ErrorCategory, TythonError};
use crate::{ast_get_list, ast_get_string, ast_getattr, ast_type_name};

mod calls;
mod classes;
mod expressions;
mod functions;
mod statements;

#[derive(Clone)]
struct FunctionSignature {
    param_names: Vec<String>,
    default_values: Vec<Option<crate::tir::TirExpr>>,
}

macro_rules! define_error_helpers {
    ($($name:ident => $category:ident),* $(,)?) => {
        $(
            fn $name(&self, line: usize, msg: impl Into<String>) -> anyhow::Error {
                self.make_error(ErrorCategory::$category, line, msg.into())
            }
        )*
    }
}

pub struct Lowering {
    symbol_table: HashMap<String, Type>,

    current_module_name: String,
    current_return_type: Option<Type>,
    scopes: Vec<HashMap<String, Type>>,
    current_file: String,
    source_lines: Vec<String>,
    current_function_name: Option<String>,

    class_registry: HashMap<String, ClassInfo>,
    current_class: Option<String>,

    // Accumulated from classes defined inside function/method bodies
    deferred_functions: Vec<TirFunction>,
    deferred_classes: Vec<ClassInfo>,
    internal_tmp_counter: usize,

    // Statements generated by list comprehensions that must be emitted
    // before the expression that uses the comprehension result.
    pre_stmts: Vec<TirStmt>,

    // Optional contextual type hint for lowering empty list literals (`[]`).
    // Used in typed contexts (e.g., annotated list comprehensions).
    empty_list_hint: Option<ValueType>,

    // Depth counter: >0 when inside a try/except block that has a finally clause.
    // `return` is forbidden inside such blocks because the codegen cannot
    // guarantee that the finally block executes before the function exits.
    in_try_finally_depth: usize,

    // Maps local function names to their mangled names, used to distinguish
    // direct calls (to known functions) from indirect calls (through variables).
    function_mangled_names: HashMap<String, String>,

    // Global map of lowered function signatures, keyed by mangled name.
    // Used for keyword/default argument binding at call sites.
    function_signatures: HashMap<String, FunctionSignature>,

    // Hidden captured variables for lifted nested functions.
    // Keyed by mangled function name, value is ordered (name, type) capture list.
    nested_function_captures: HashMap<String, Vec<(String, Type)>>,
}

impl Default for Lowering {
    fn default() -> Self {
        Self::new()
    }
}

impl Lowering {
    pub fn new() -> Self {
        Self {
            symbol_table: HashMap::new(),
            current_module_name: String::new(),
            current_return_type: None,
            scopes: Vec::new(),
            current_file: String::new(),
            source_lines: Vec::new(),
            current_function_name: None,
            class_registry: HashMap::new(),
            current_class: None,
            deferred_functions: Vec::new(),
            deferred_classes: Vec::new(),
            internal_tmp_counter: 0,
            pre_stmts: Vec::new(),
            empty_list_hint: None,
            function_mangled_names: HashMap::new(),
            function_signatures: HashMap::new(),
            nested_function_captures: HashMap::new(),
            in_try_finally_depth: 0,
        }
    }

    // ── error helpers ──────────────────────────────────────────────────

    fn make_error(&self, category: ErrorCategory, line: usize, message: String) -> anyhow::Error {
        TythonError {
            category,
            message,
            file: self.current_file.clone(),
            line,
            source_line: self.source_lines.get(line.wrapping_sub(1)).cloned(),
            function_name: self.current_function_name.clone(),
        }
        .into()
    }

    define_error_helpers! {
        type_error     => TypeError,
        name_error     => NameError,
        syntax_error   => SyntaxError,
        value_error    => ValueError,
        attribute_error => AttributeError,
    }

    // ── scope helpers ──────────────────────────────────────────────────

    fn push_scope(&mut self) {
        self.scopes.push(HashMap::new());
    }

    fn pop_scope(&mut self) {
        self.scopes.pop();
    }

    fn declare(&mut self, name: String, ty: Type) {
        self.scopes.last_mut().unwrap().insert(name, ty);
    }

    fn fresh_internal(&mut self, prefix: &str) -> String {
        let name = format!("__tython${}${}", prefix, self.internal_tmp_counter);
        self.internal_tmp_counter += 1;
        name
    }

    fn lookup(&self, name: &str) -> Option<&Type> {
        for scope in self.scopes.iter().rev() {
            if let Some(ty) = scope.get(name) {
                return Some(ty);
            }
        }
        None
    }

    /// Lower a block of statements inside a new scope.
    fn lower_block(&mut self, stmts: &Bound<PyList>) -> Result<Vec<TirStmt>> {
        self.push_scope();
        let mut body = Vec::new();
        for stmt_node in stmts.iter() {
            body.extend(self.lower_stmt(&stmt_node)?);
        }
        self.pop_scope();
        Ok(body)
    }

    /// Lower a block of statements in the current scope (Python block semantics).
    fn lower_block_in_current_scope(&mut self, stmts: &Bound<PyList>) -> Result<Vec<TirStmt>> {
        let mut body = Vec::new();
        for stmt_node in stmts.iter() {
            body.extend(self.lower_stmt(&stmt_node)?);
        }
        Ok(body)
    }

    /// Look up a class in the registry, or return a NameError.
    fn lookup_class(&self, line: usize, class_name: &str) -> Result<ClassInfo> {
        self.class_registry
            .get(class_name)
            .cloned()
            .ok_or_else(|| self.name_error(line, format!("unknown class `{}`", class_name)))
    }

    /// Look up a field index in a class, or return an AttributeError.
    fn lookup_field_index(
        &self,
        line: usize,
        class_info: &ClassInfo,
        field_name: &str,
    ) -> Result<usize> {
        class_info
            .field_map
            .get(field_name)
            .copied()
            .ok_or_else(|| {
                self.attribute_error(
                    line,
                    format!("class `{}` has no field `{}`", class_info.name, field_name),
                )
            })
    }

    // ── helpers: Type → ValueType conversion ────────────────────────

    fn to_value_type(ty: &Type) -> ValueType {
        ValueType::from_type(ty).expect("ICE: expected a value type")
    }

    fn to_opt_value_type(ty: &Type) -> Option<ValueType> {
        match ty {
            Type::Unit => None,
            other => Some(Self::to_value_type(other)),
        }
    }

    /// Lower Python truthiness into an explicit bool-producing TIR expression.
    fn lower_truthy_to_bool(
        &mut self,
        line: usize,
        expr: TirExpr,
        context: &str,
    ) -> Result<TirExpr> {
        match expr.ty {
            ValueType::Bool => Ok(expr),
            ValueType::Int => Ok(TirExpr {
                kind: TirExprKind::Cast {
                    kind: CastKind::IntToBool,
                    arg: Box::new(expr),
                },
                ty: ValueType::Bool,
            }),
            ValueType::Float => Ok(TirExpr {
                kind: TirExprKind::Cast {
                    kind: CastKind::FloatToBool,
                    arg: Box::new(expr),
                },
                ty: ValueType::Bool,
            }),
            ValueType::Str
            | ValueType::Bytes
            | ValueType::ByteArray
            | ValueType::List(_)
            | ValueType::Dict(_, _)
            | ValueType::Set(_) => {
                let len_fn = match &expr.ty {
                    ValueType::Str => builtin::BuiltinFn::StrLen,
                    ValueType::Bytes => builtin::BuiltinFn::BytesLen,
                    ValueType::ByteArray => builtin::BuiltinFn::ByteArrayLen,
                    ValueType::List(_) => builtin::BuiltinFn::ListLen,
                    ValueType::Dict(_, _) => builtin::BuiltinFn::DictLen,
                    ValueType::Set(_) => builtin::BuiltinFn::SetLen,
                    _ => unreachable!(),
                };
                let len_expr = TirExpr {
                    kind: TirExprKind::ExternalCall {
                        func: len_fn,
                        args: vec![expr],
                    },
                    ty: ValueType::Int,
                };
                Ok(TirExpr {
                    kind: TirExprKind::Cast {
                        kind: CastKind::IntToBool,
                        arg: Box::new(len_expr),
                    },
                    ty: ValueType::Bool,
                })
            }
            ValueType::Tuple(elements) => Ok(TirExpr {
                kind: TirExprKind::IntLiteral((!elements.is_empty()) as i64),
                ty: ValueType::Bool,
            }),
            ValueType::Class(_) => Ok(TirExpr {
                kind: TirExprKind::IntLiteral(1),
                ty: ValueType::Bool,
            }),
            ValueType::Function { .. } => {
                Err(self.type_error(line, format!("cannot use `{}` in {}", expr.ty, context)))
            }
        }
    }

    // ── module / function lowering ─────────────────────────────────────

    pub fn lower_module(
        &mut self,
        canonical_path: &Path,
        module_name: &str,
        imports: &HashMap<String, Type>,
    ) -> Result<TirModule> {
        self.scopes.clear();
        self.current_return_type = None;
        self.current_module_name = module_name.to_string();
        self.current_file = canonical_path.display().to_string();
        self.current_function_name = None;
        self.internal_tmp_counter = 0;
        self.function_mangled_names.clear();

        self.push_scope();

        for (local_name, ty) in imports {
            self.declare(local_name.clone(), ty.clone());
        }

        Python::attach(|py| -> Result<_> {
            let source = std::fs::read_to_string(canonical_path)?;
            self.source_lines = source.lines().map(String::from).collect();
            let ast_module = PyModule::import(py, "ast").unwrap();
            let py_ast = ast_module
                .call_method1("parse", (source.as_str(),))
                .unwrap();

            self.lower_py_ast(&py_ast)
        })
    }

    fn lower_py_ast(&mut self, py_ast: &Bound<PyAny>) -> Result<TirModule> {
        let body_list = ast_get_list!(py_ast, "body");

        // Pass 1: Collect class definitions (two sub-phases for cross-referencing)
        // Phase 1a: Register all class names (with module-qualified names), recursing into nested
        self.discover_classes(&body_list, &self.current_module_name.clone())?;
        // Phase 1b: Fill in fields and methods, recursing into nested
        self.collect_classes(&body_list, &self.current_module_name.clone())?;

        // Pass 2: Collect function signatures
        for node in body_list.iter() {
            if ast_type_name!(node) == "FunctionDef" {
                self.collect_function_signature(&node)?;
            }
        }

        // Pass 3: Lower everything
        let mut functions = HashMap::new();
        let mut module_level_stmts = Vec::new();
        let mut classes = HashMap::new();

        for node in body_list.iter() {
            match ast_type_name!(node).as_str() {
                "ClassDef" => {
                    let raw_name = ast_get_string!(node, "name");
                    let qualified = format!("{}${}", self.current_module_name, raw_name);
                    let (class_infos, class_functions) = self.lower_class_def(&node, &qualified)?;
                    for func in class_functions {
                        functions.insert(func.name.clone(), func);
                    }
                    for ci in class_infos {
                        classes.insert(ci.name.clone(), ci);
                    }
                }
                "FunctionDef" => {
                    let tir_func = self.lower_function(&node)?;
                    functions.insert(tir_func.name.clone(), tir_func);
                }
                "Import" | "ImportFrom" => {}
                _ => {
                    module_level_stmts.extend(self.lower_stmt(&node)?);
                }
            }
        }

        // Always synthesize a module main so codegen can reliably build the
        // C entry wrapper, even when a module has only definitions/imports.
        let main_func = self.build_synthetic_main(module_level_stmts);
        functions.insert(main_func.name.clone(), main_func);

        // Drain classes/functions discovered inside function/method bodies
        for ci in self.deferred_classes.drain(..) {
            classes.insert(ci.name.clone(), ci);
        }
        for func in self.deferred_functions.drain(..) {
            functions.insert(func.name.clone(), func);
        }

        for func in functions.values() {
            let func_type = Type::Function {
                params: func.params.iter().map(|p| p.ty.to_type()).collect(),
                return_type: Box::new(
                    func.return_type
                        .as_ref()
                        .map(|vt| vt.to_type())
                        .unwrap_or(Type::Unit),
                ),
            };
            self.symbol_table.insert(func.name.clone(), func_type);
        }

        Ok(TirModule { functions, classes })
    }

    // ── utility helpers ───────────────────────────────────────────────

    fn get_line(node: &Bound<PyAny>) -> usize {
        ast_getattr!(node, "lineno")
            .extract::<usize>()
            .unwrap_or_default()
    }

    fn mangle_name(&self, name: &str) -> String {
        format!("{}${}", self.current_module_name, name)
    }

    fn register_function_signature(
        &mut self,
        mangled_name: String,
        param_names: Vec<String>,
        default_values: Vec<Option<crate::tir::TirExpr>>,
    ) {
        self.function_signatures.insert(
            mangled_name,
            FunctionSignature {
                param_names,
                default_values,
            },
        );
    }

    fn ensure_supported_default_expr(&self, line: usize, expr: &crate::tir::TirExpr) -> Result<()> {
        use crate::tir::TirExprKind;

        match &expr.kind {
            TirExprKind::IntLiteral(_)
            | TirExprKind::FloatLiteral(_)
            | TirExprKind::StrLiteral(_)
            | TirExprKind::BytesLiteral(_) => Ok(()),
            TirExprKind::UnaryOp { operand, .. } => {
                self.ensure_supported_default_expr(line, operand)
            }
            TirExprKind::BinOp { left, right, .. } => {
                self.ensure_supported_default_expr(line, left)?;
                self.ensure_supported_default_expr(line, right)
            }
            TirExprKind::Cast { arg, .. } => self.ensure_supported_default_expr(line, arg),
            TirExprKind::TupleLiteral { elements, .. } => {
                for elt in elements {
                    self.ensure_supported_default_expr(line, elt)?;
                }
                Ok(())
            }
            TirExprKind::ListLiteral { elements, .. } => {
                for elt in elements {
                    self.ensure_supported_default_expr(line, elt)?;
                }
                Ok(())
            }
            _ => Err(self.syntax_error(
                line,
                "unsupported default argument expression (only constant expressions are supported)",
            )),
        }
    }

    /// Try to resolve an AST node as a dotted class/module path to a qualified class name.
    /// E.g., `Outer.Inner` → `module$Outer$Inner`, `mod.Class` → `mod$Class`
    fn try_resolve_class_path(&self, node: &Bound<PyAny>) -> Option<String> {
        match ast_type_name!(node).as_str() {
            "Name" => {
                let name = ast_get_string!(node, "id");
                match self.lookup(&name)? {
                    Type::Class(qualified) => Some(qualified.clone()),
                    Type::Module(mod_path) => Some(mod_path.clone()),
                    _ => None,
                }
            }
            "Attribute" => {
                let value_node = ast_getattr!(node, "value");
                let attr = ast_get_string!(node, "attr");
                let parent = self.try_resolve_class_path(&value_node)?;
                let candidate = format!("{}${}", parent, attr);
                if self.class_registry.contains_key(&candidate) {
                    Some(candidate)
                } else {
                    None
                }
            }
            _ => None,
        }
    }

    fn convert_return_type(&self, node: &Bound<PyAny>) -> Result<Type> {
        let returns = ast_getattr!(node, "returns");
        if returns.is_none() {
            Ok(Type::Unit)
        } else {
            self.convert_type_annotation(&returns)
        }
    }

    fn convert_type_annotation(&self, node: &Bound<PyAny>) -> Result<Type> {
        let node_type = ast_type_name!(node);
        match node_type.as_str() {
            "Name" => {
                let id = ast_get_string!(node, "id");
                match id.as_str() {
                    "int" => Ok(Type::Int),
                    "float" => Ok(Type::Float),
                    "bool" => Ok(Type::Bool),
                    "str" => Ok(Type::Str),
                    "bytes" => Ok(Type::Bytes),
                    "bytearray" => Ok(Type::ByteArray),
                    other => {
                        if let Some(ty) = self.lookup(other).cloned() {
                            match ty {
                                Type::Class(_) => Ok(ty),
                                Type::Module(ref mangled) => {
                                    // from-import of a class: `from mod import ClassName`
                                    if self.class_registry.contains_key(mangled) {
                                        Ok(Type::Class(mangled.clone()))
                                    } else {
                                        bail!("'{}' is not a type", other)
                                    }
                                }
                                _ => bail!("'{}' is not a type", other),
                            }
                        } else {
                            bail!("unsupported type `{}`", id)
                        }
                    }
                }
            }
            "Constant" => {
                let value = ast_getattr!(node, "value");
                if value.is_none() {
                    Ok(Type::Unit)
                } else if let Ok(s) = value.extract::<String>() {
                    // String literal as forward reference, e.g. -> "Countdown"
                    // First try simple class name lookup
                    if let Some(ty) = self.lookup(&s).cloned() {
                        if let Type::Class(_) = ty {
                            return Ok(ty);
                        }
                    }
                    if self.class_registry.contains_key(&s) {
                        return Ok(Type::Class(s));
                    }
                    // If not a simple name, parse as a type expression
                    // (e.g., "list[int]", "tuple[int, str]")
                    Python::attach(|py| {
                        let ast_module = PyModule::import(py, "ast").unwrap();
                        let parsed = ast_module.call_method1("parse", (s.as_str(),)).unwrap();
                        let body = ast_get_list!(&parsed, "body");
                        if body.len() != 1 {
                            bail!("unsupported forward reference type `{}`", s);
                        }
                        let expr_stmt = body.get_item(0)?;
                        if ast_type_name!(expr_stmt) != "Expr" {
                            bail!("unsupported forward reference type `{}`", s);
                        }
                        let inner_node = ast_getattr!(expr_stmt, "value");
                        self.convert_type_annotation(&inner_node)
                    })
                } else {
                    bail!("unsupported constant type annotation")
                }
            }
            "Attribute" => {
                if let Some(qualified) = self.try_resolve_class_path(node) {
                    if self.class_registry.contains_key(&qualified) {
                        return Ok(Type::Class(qualified));
                    }
                }
                bail!("unsupported type annotation: `{}`", node_type)
            }
            "Subscript" => {
                let value_node = ast_getattr!(node, "value");
                let slice_node = ast_getattr!(node, "slice");
                if ast_type_name!(value_node) != "Name" {
                    bail!("unsupported subscript type annotation");
                }
                let container_name = ast_get_string!(value_node, "id");
                match container_name.as_str() {
                    "list" => {
                        let inner_ty = self.convert_type_annotation(&slice_node)?;
                        match &inner_ty {
                            Type::Int
                            | Type::Float
                            | Type::Bool
                            | Type::Str
                            | Type::Bytes
                            | Type::ByteArray
                            | Type::Class(_)
                            | Type::List(_)
                            | Type::Dict(_, _)
                            | Type::Set(_)
                            | Type::Tuple(_) => {}
                            _ => bail!("unsupported list element type `{}`", inner_ty),
                        }
                        Ok(Type::List(Box::new(inner_ty)))
                    }
                    "dict" => {
                        if ast_type_name!(slice_node) != "Tuple" {
                            bail!("dict annotation must be `dict[key_type, value_type]`");
                        }
                        let elts = ast_get_list!(slice_node, "elts");
                        if elts.len() != 2 {
                            bail!("dict annotation must have exactly two type arguments");
                        }
                        let key_ty = self.convert_type_annotation(&elts.get_item(0)?)?;
                        let value_ty = self.convert_type_annotation(&elts.get_item(1)?)?;
                        if ValueType::from_type(&key_ty).is_none() {
                            bail!("unsupported dict key type `{}`", key_ty);
                        }
                        if ValueType::from_type(&value_ty).is_none() {
                            bail!("unsupported dict value type `{}`", value_ty);
                        }
                        Ok(Type::Dict(Box::new(key_ty), Box::new(value_ty)))
                    }
                    "set" => {
                        let inner_ty = self.convert_type_annotation(&slice_node)?;
                        if ValueType::from_type(&inner_ty).is_none() {
                            bail!("unsupported set element type `{}`", inner_ty);
                        }
                        Ok(Type::Set(Box::new(inner_ty)))
                    }
                    "tuple" => {
                        let element_types = if ast_type_name!(slice_node) == "Tuple" {
                            let elts = ast_get_list!(slice_node, "elts");
                            let mut out = Vec::with_capacity(elts.len());
                            for elt in elts.iter() {
                                out.push(self.convert_type_annotation(&elt)?);
                            }
                            out
                        } else {
                            vec![self.convert_type_annotation(&slice_node)?]
                        };
                        if ValueType::from_type(&Type::Tuple(element_types.clone())).is_none() {
                            bail!("unsupported tuple element type in annotation");
                        }
                        Ok(Type::Tuple(element_types))
                    }
                    _ => bail!("unsupported generic type `{}`", container_name),
                }
            }
            _ => bail!("unsupported type annotation: `{}`", node_type),
        }
    }

    fn convert_cmpop(node: &Bound<PyAny>) -> Result<CmpOp> {
        let op_type = ast_type_name!(node);
        match op_type.as_str() {
            "Eq" => Ok(CmpOp::Eq),
            "NotEq" => Ok(CmpOp::NotEq),
            "Lt" => Ok(CmpOp::Lt),
            "LtE" => Ok(CmpOp::LtEq),
            "Gt" => Ok(CmpOp::Gt),
            "GtE" => Ok(CmpOp::GtEq),
            "In" => Ok(CmpOp::In),
            "NotIn" => Ok(CmpOp::NotIn),
            "Is" => Ok(CmpOp::Is),
            "IsNot" => Ok(CmpOp::IsNot),
            _ => bail!("unsupported comparison operator: `{}`", op_type),
        }
    }

    fn convert_binop(node: &Bound<PyAny>) -> Result<RawBinOp> {
        let op_type = ast_type_name!(node);
        match op_type.as_str() {
            "Add" => Ok(RawBinOp::Arith(ArithBinOp::Add)),
            "Sub" => Ok(RawBinOp::Arith(ArithBinOp::Sub)),
            "Mult" => Ok(RawBinOp::Arith(ArithBinOp::Mul)),
            "Div" => Ok(RawBinOp::Arith(ArithBinOp::Div)),
            "FloorDiv" => Ok(RawBinOp::Arith(ArithBinOp::FloorDiv)),
            "Mod" => Ok(RawBinOp::Arith(ArithBinOp::Mod)),
            "Pow" => Ok(RawBinOp::Arith(ArithBinOp::Pow)),
            "BitAnd" => Ok(RawBinOp::Bitwise(BitwiseBinOp::BitAnd)),
            "BitOr" => Ok(RawBinOp::Bitwise(BitwiseBinOp::BitOr)),
            "BitXor" => Ok(RawBinOp::Bitwise(BitwiseBinOp::BitXor)),
            "LShift" => Ok(RawBinOp::Bitwise(BitwiseBinOp::LShift)),
            "RShift" => Ok(RawBinOp::Bitwise(BitwiseBinOp::RShift)),
            _ => bail!("unsupported binary operator: `{}`", op_type),
        }
    }

    fn convert_unaryop(op_type: &str) -> UnaryOpKind {
        match op_type {
            "USub" => UnaryOpKind::Neg,
            "UAdd" => UnaryOpKind::Pos,
            "Not" => UnaryOpKind::Not,
            "Invert" => UnaryOpKind::BitNot,
            _ => unreachable!("Python add new unary operator"),
        }
    }
}
