use anyhow::{bail, Result};
use pyo3::prelude::*;
use pyo3::types::{PyList, PyModule};
use std::collections::{HashMap, HashSet};
use std::path::Path;

use super::{
    builtin, ArithBinOp, BitwiseBinOp, CastKind, CmpOp, RawBinOp, TirClassField, TirClassInfo,
    TirExpr, TirExprKind, TirFunction, TirModule, TirStmt, UnaryOpKind, ValueType,
};
use crate::ast::{ClassInfo, Type};
use crate::errors::{ErrorCategory, TythonError};
use crate::tir::{intrinsic_tag, IntrinsicOp};
use crate::{ast_get_list, ast_get_string, ast_getattr, ast_type_name};

mod call;
mod classes;
pub mod expr;
mod functions;
pub mod method;
mod stmt;
mod tuple_class;

#[derive(Clone)]
struct FunctionSignature {
    param_names: Vec<String>,
    default_values: Vec<Option<crate::tir::TirExpr>>,
}

macro_rules! define_error_helpers {
    ($($name:ident => $category:ident),* $(,)?) => {
        $(
            fn $name(&self, line: usize, msg: impl Into<String>) -> anyhow::Error {
                self.make_error(ErrorCategory::$category, line, msg.into())
            }
        )*
    }
}

pub struct Lowering {
    symbol_table: HashMap<String, Type>,

    current_module_name: String,
    current_return_type: Option<Type>,
    scopes: Vec<HashMap<String, Type>>,
    non_capture_scopes: Vec<HashSet<String>>,
    current_file: String,
    source_lines: Vec<String>,
    current_function_name: Option<String>,

    class_registry: HashMap<String, ClassInfo>,
    current_class: Option<String>,

    // Accumulated from classes defined inside function/method bodies
    deferred_functions: Vec<TirFunction>,
    deferred_classes: Vec<ClassInfo>,
    internal_tmp_counter: usize,

    // Statements generated by list comprehensions that must be emitted
    // before the expression that uses the comprehension result.
    pre_stmts: Vec<TirStmt>,

    // Optional contextual type hint for lowering empty list literals (`[]`).
    // Used in typed contexts (e.g., annotated list comprehensions).
    empty_list_hint: Option<ValueType>,

    // Depth counter: >0 when inside a try/except block that has a finally clause.
    // `return` is forbidden inside such blocks because the codegen cannot
    // guarantee that the finally block executes before the function exits.
    in_try_finally_depth: usize,

    // Maps local function names to their mangled names, used to distinguish
    // direct calls (to known functions) from indirect calls (through variables).
    function_mangled_names: HashMap<String, String>,

    // Global map of lowered function signatures, keyed by mangled name.
    // Used for keyword/default argument binding at call sites.
    function_signatures: HashMap<String, FunctionSignature>,

    // Hidden captured variables for lifted nested functions.
    // Keyed by mangled function name, value is ordered (name, type) capture list.
    nested_function_captures: HashMap<String, Vec<(String, Type)>>,

    // Intrinsic compare instances required by this module.
    intrinsic_instances: HashMap<(IntrinsicOp, ValueType), i64>,

    // Maps auto-generated tuple class names to their element types.
    // E.g. "__tuple$int|str|bool" -> [Int, Str, Bool]
    tuple_class_elements: HashMap<String, Vec<ValueType>>,
}

impl Default for Lowering {
    fn default() -> Self {
        Self::new()
    }
}

impl Lowering {
    pub fn new() -> Self {
        Self {
            symbol_table: HashMap::new(),
            current_module_name: String::new(),
            current_return_type: None,
            scopes: Vec::new(),
            non_capture_scopes: Vec::new(),
            current_file: String::new(),
            source_lines: Vec::new(),
            current_function_name: None,
            class_registry: HashMap::new(),
            current_class: None,
            deferred_functions: Vec::new(),
            deferred_classes: Vec::new(),
            internal_tmp_counter: 0,
            pre_stmts: Vec::new(),
            empty_list_hint: None,
            function_mangled_names: HashMap::new(),
            function_signatures: HashMap::new(),
            nested_function_captures: HashMap::new(),
            in_try_finally_depth: 0,
            intrinsic_instances: HashMap::new(),
            tuple_class_elements: HashMap::new(),
        }
    }

    // ── error helpers ──────────────────────────────────────────────────

    fn make_error(&self, category: ErrorCategory, line: usize, message: String) -> anyhow::Error {
        TythonError {
            category,
            message,
            file: self.current_file.clone(),
            line,
            source_line: self.source_lines.get(line.wrapping_sub(1)).cloned(),
            function_name: self.current_function_name.clone(),
        }
        .into()
    }

    define_error_helpers! {
        type_error     => TypeError,
        name_error     => NameError,
        syntax_error   => SyntaxError,
        value_error    => ValueError,
        attribute_error => AttributeError,
    }

    // ── scope helpers ──────────────────────────────────────────────────

    fn push_scope(&mut self) {
        self.scopes.push(HashMap::new());
        self.non_capture_scopes.push(HashSet::new());
    }

    fn pop_scope(&mut self) {
        self.scopes.pop();
        self.non_capture_scopes.pop();
    }

    fn declare(&mut self, name: String, ty: Type) {
        self.scopes.last_mut().unwrap().insert(name, ty);
    }

    fn declare_non_capture_symbol(&mut self, name: String, ty: Type) {
        self.declare(name.clone(), ty);
        self.non_capture_scopes.last_mut().unwrap().insert(name);
    }

    fn fresh_internal(&mut self, prefix: &str) -> String {
        let name = format!("__tython${}${}", prefix, self.internal_tmp_counter);
        self.internal_tmp_counter += 1;
        name
    }

    fn lower_class_info(&mut self, ci: &ClassInfo) -> TirClassInfo {
        TirClassInfo {
            name: ci.name.clone(),
            fields: ci
                .fields
                .iter()
                .map(|f| TirClassField {
                    name: f.name.clone(),
                    ty: self.value_type_from_type(&f.ty),
                    index: f.index,
                })
                .collect(),
        }
    }

    fn lookup(&self, name: &str) -> Option<&Type> {
        for scope in self.scopes.iter().rev() {
            if let Some(ty) = scope.get(name) {
                return Some(ty);
            }
        }
        None
    }

    /// Lower a block of statements inside a new scope.
    fn lower_block(&mut self, stmts: &Bound<PyList>) -> Result<Vec<TirStmt>> {
        self.push_scope();
        let mut body = Vec::new();
        for stmt_node in stmts.iter() {
            body.extend(self.lower_stmt(&stmt_node)?);
        }
        self.pop_scope();
        Ok(body)
    }

    /// Lower a block of statements in the current scope (Python block semantics).
    fn lower_block_in_current_scope(&mut self, stmts: &Bound<PyList>) -> Result<Vec<TirStmt>> {
        let mut body = Vec::new();
        for stmt_node in stmts.iter() {
            body.extend(self.lower_stmt(&stmt_node)?);
        }
        Ok(body)
    }

    /// Look up a class in the registry, or return a NameError.
    fn lookup_class(&self, line: usize, class_name: &str) -> Result<ClassInfo> {
        self.class_registry
            .get(class_name)
            .cloned()
            .ok_or_else(|| self.name_error(line, format!("unknown class `{}`", class_name)))
    }

    fn require_class_magic_method(
        &self,
        line: usize,
        class_name: &str,
        method_name: &str,
    ) -> Result<()> {
        let class_info = self.lookup_class(line, class_name)?;
        let Some(method) = class_info.methods.get(method_name) else {
            return Err(self.type_error(
                line,
                format!(
                    "list[{}] requires `{}` with signature `({}) -> bool`",
                    class_name, method_name, class_name
                ),
            ));
        };

        if method.params.len() != 1
            || method.params[0] != Type::Class(class_name.to_string())
            || method.return_type != Type::Bool
        {
            return Err(self.type_error(
                line,
                format!(
                    "list[{}] requires `{}` with signature `({}) -> bool`",
                    class_name, method_name, class_name
                ),
            ));
        }

        Ok(())
    }

    pub(in crate::tir::lower) fn require_list_leaf_eq_support(&self) {
        self.require_intrinsic_eq_support()
    }

    pub(in crate::tir::lower) fn require_intrinsic_eq_support(&self) {
        // All types support equality comparison:
        // - Primitives (Int, Float, Bool, Str, Bytes, ByteArray): structural equality
        // - List, Class with __eq__: structural equality via registered intrinsic
        // - Everything else (Set, Dict, Function, Class without __eq__):
        //   identity-based equality/hash fallback (pointer comparison),
        //   matching Python's default object.__eq__ and object.__hash__
    }

    pub(in crate::tir::lower) fn require_list_leaf_lt_support(
        &self,
        line: usize,
        ty: &ValueType,
    ) -> Result<()> {
        match ty {
            ValueType::Int
            | ValueType::Float
            | ValueType::Bool
            | ValueType::Str
            | ValueType::Bytes
            | ValueType::ByteArray => Ok(()),
            ValueType::List(inner) => self.require_list_leaf_lt_support(line, inner),
            ValueType::Class(class_name) => {
                self.require_class_magic_method(line, class_name, "__lt__")
            }
            _ => Err(self.type_error(
                line,
                format!(
                    "list[{}].sort() is not supported; element type has no `__lt__`",
                    ty
                ),
            )),
        }
    }

    pub(in crate::tir::lower) fn register_intrinsic_instance(
        &mut self,
        op: IntrinsicOp,
        ty: &ValueType,
    ) -> i64 {
        let key = (op, ty.clone());
        if let Some(tag) = self.intrinsic_instances.get(&key) {
            return *tag;
        }
        let tag = intrinsic_tag(op, ty);
        self.intrinsic_instances.insert(key, tag);
        self.register_intrinsic_list_dependencies(op, ty);
        tag
    }

    fn register_intrinsic_list_dependencies(&mut self, op: IntrinsicOp, ty: &ValueType) {
        match ty {
            ValueType::List(inner) => {
                self.register_intrinsic_instance(op, inner);
            }
            ValueType::Dict(key, value) if op == IntrinsicOp::Str => {
                self.register_intrinsic_instance(op, key);
                self.register_intrinsic_instance(op, value);
            }
            ValueType::Set(inner) if op == IntrinsicOp::Str => {
                self.register_intrinsic_instance(op, inner);
            }
            ValueType::Class(name) if self.is_tuple_class(name) => {
                let fields = self.tuple_element_types(name).to_vec();
                for field in &fields {
                    self.register_intrinsic_list_dependencies(op, field);
                }
            }
            _ => {}
        }
    }

    /// Look up a field index in a class, or return an AttributeError.
    fn lookup_field_index(
        &self,
        line: usize,
        class_info: &ClassInfo,
        field_name: &str,
    ) -> Result<usize> {
        class_info
            .field_map
            .get(field_name)
            .copied()
            .ok_or_else(|| {
                self.attribute_error(
                    line,
                    format!("class `{}` has no field `{}`", class_info.name, field_name),
                )
            })
    }

    // ── helpers: Type → ValueType conversion ────────────────────────

    fn value_type_from_type(&mut self, ty: &Type) -> ValueType {
        match ty {
            Type::Tuple(elements) => {
                let elem_vtys: Vec<ValueType> = elements
                    .iter()
                    .map(|t| self.value_type_from_type(t))
                    .collect();
                let class_name = self.get_or_create_tuple_class(&elem_vtys);
                ValueType::Class(class_name)
            }
            Type::List(inner) => ValueType::List(Box::new(self.value_type_from_type(inner))),
            Type::Dict(key, value) => ValueType::Dict(
                Box::new(self.value_type_from_type(key)),
                Box::new(self.value_type_from_type(value)),
            ),
            Type::Set(inner) => ValueType::Set(Box::new(self.value_type_from_type(inner))),
            Type::Function {
                params,
                return_type,
            } => {
                let vt_params: Vec<ValueType> = params
                    .iter()
                    .map(|p| self.value_type_from_type(p))
                    .collect();
                let vt_ret = match return_type.as_ref() {
                    Type::Unit => None,
                    other => Some(Box::new(self.value_type_from_type(other))),
                };
                ValueType::Function {
                    params: vt_params,
                    return_type: vt_ret,
                }
            }
            _ => ValueType::from_type(ty).expect("ICE: expected a value type"),
        }
    }

    fn opt_value_type_from_type(&mut self, ty: &Type) -> Option<ValueType> {
        match ty {
            Type::Unit => None,
            other => Some(self.value_type_from_type(other)),
        }
    }

    /// Lower Python truthiness into an explicit bool-producing TIR expression.
    fn lower_truthy_to_bool(
        &mut self,
        line: usize,
        expr: TirExpr,
        context: &str,
    ) -> Result<TirExpr> {
        match expr.ty {
            ValueType::Bool => Ok(expr),
            ValueType::Int => Ok(TirExpr {
                kind: TirExprKind::Cast {
                    kind: CastKind::IntToBool,
                    arg: Box::new(expr),
                },
                ty: ValueType::Bool,
            }),
            ValueType::Float => Ok(TirExpr {
                kind: TirExprKind::Cast {
                    kind: CastKind::FloatToBool,
                    arg: Box::new(expr),
                },
                ty: ValueType::Bool,
            }),
            ValueType::Str
            | ValueType::Bytes
            | ValueType::ByteArray
            | ValueType::List(_)
            | ValueType::Dict(_, _)
            | ValueType::Set(_) => {
                let len_fn = if matches!(&expr.ty, ValueType::Str) {
                    builtin::BuiltinFn::StrLen
                } else if matches!(&expr.ty, ValueType::Bytes) {
                    builtin::BuiltinFn::BytesLen
                } else if matches!(&expr.ty, ValueType::ByteArray) {
                    builtin::BuiltinFn::ByteArrayLen
                } else if matches!(&expr.ty, ValueType::List(_)) {
                    builtin::BuiltinFn::ListLen
                } else if matches!(&expr.ty, ValueType::Dict(_, _)) {
                    builtin::BuiltinFn::DictLen
                } else {
                    builtin::BuiltinFn::SetLen
                };
                let len_expr = TirExpr {
                    kind: TirExprKind::ExternalCall {
                        func: len_fn,
                        args: vec![expr],
                    },
                    ty: ValueType::Int,
                };
                Ok(TirExpr {
                    kind: TirExprKind::Cast {
                        kind: CastKind::IntToBool,
                        arg: Box::new(len_expr),
                    },
                    ty: ValueType::Bool,
                })
            }
            ValueType::Class(ref name) if self.is_tuple_class(name) => {
                let is_nonempty = !self.tuple_element_types(name).is_empty();
                Ok(TirExpr {
                    kind: TirExprKind::BoolLiteral(is_nonempty),
                    ty: ValueType::Bool,
                })
            }
            ValueType::Class(_) => Ok(TirExpr {
                kind: TirExprKind::BoolLiteral(true),
                ty: ValueType::Bool,
            }),
            ValueType::File => Ok(TirExpr {
                kind: TirExprKind::BoolLiteral(true),
                ty: ValueType::Bool,
            }),
            ValueType::Function { .. } => {
                Err(self.type_error(line, format!("cannot use `{}` in {}", expr.ty, context)))
            }
        }
    }

    // ── module / function lowering ─────────────────────────────────────

    pub fn lower_module(
        &mut self,
        canonical_path: &Path,
        module_name: &str,
        imports: &HashMap<String, Type>,
    ) -> Result<TirModule> {
        self.scopes.clear();
        self.non_capture_scopes.clear();
        self.current_return_type = None;
        self.current_module_name = module_name.to_string();
        self.current_file = canonical_path.display().to_string();
        self.current_function_name = None;
        self.internal_tmp_counter = 0;
        self.function_mangled_names.clear();
        self.intrinsic_instances.clear();

        self.push_scope();

        for (local_name, ty) in imports {
            self.declare(local_name.clone(), ty.clone());
        }

        Python::attach(|py| -> Result<_> {
            let source = std::fs::read_to_string(canonical_path)?;
            self.source_lines = source.lines().map(String::from).collect();
            let ast_module = PyModule::import(py, "ast").unwrap();
            let py_ast = ast_module
                .call_method1("parse", (source.as_str(),))
                .unwrap();

            self.lower_py_ast(&py_ast)
        })
    }

    fn lower_py_ast(&mut self, py_ast: &Bound<PyAny>) -> Result<TirModule> {
        let body_list = ast_get_list!(py_ast, "body");

        // Pass 1: Collect class definitions (two sub-phases for cross-referencing)
        // Phase 1a: Register all class names (with module-qualified names), recursing into nested
        self.discover_classes(&body_list, &self.current_module_name.clone())?;
        // Phase 1b: Fill in fields and methods, recursing into nested
        self.collect_classes(&body_list, &self.current_module_name.clone())?;

        // Pass 2: Collect function signatures
        for node in body_list.iter() {
            if ast_type_name!(node) == "FunctionDef" {
                self.collect_function_signature(&node)?;
            }
        }

        // Pass 3: Lower everything
        let mut functions = HashMap::new();
        let mut module_level_stmts = Vec::new();
        let mut classes = HashMap::new();

        for node in body_list.iter() {
            match ast_type_name!(node).as_str() {
                "ClassDef" => {
                    let raw_name = ast_get_string!(node, "name");
                    let qualified = format!("{}${}", self.current_module_name, raw_name);
                    let (class_infos, class_functions) = self.lower_class_def(&node, &qualified)?;
                    for func in class_functions {
                        functions.insert(func.name.clone(), func);
                    }
                    for ci in &class_infos {
                        let tir_ci = self.lower_class_info(ci);
                        classes.insert(tir_ci.name.clone(), tir_ci);
                    }
                }
                "FunctionDef" => {
                    let tir_func = self.lower_function(&node)?;
                    functions.insert(tir_func.name.clone(), tir_func);
                }
                "Import" | "ImportFrom" => {}
                "Pass" => {
                    // Allow pass statements at module level (they are no-ops)
                }
                "Expr" => {
                    // Allow expression statements only if they are docstrings or ellipsis
                    let value_node = ast_getattr!(node, "value");
                    if ast_type_name!(value_node) == "Constant" {
                        let value = ast_getattr!(value_node, "value");
                        let type_name = value.get_type().name().map_err(|_| {
                            let line = Self::get_line(&node);
                            self.syntax_error(line, "failed to get constant type name")
                        })?;

                        // Allow ellipsis and string literals (docstrings) at module level
                        if type_name == "ellipsis"
                            || value.is_instance_of::<pyo3::types::PyString>()
                        {
                            // These are allowed at module level but don't generate code
                            continue;
                        }
                    }

                    // Other expression statements are not allowed at module level
                    let line = Self::get_line(&node);
                    return Err(self.syntax_error(
                        line,
                        "Module-level executable code must be inside 'if __name__ == \"__main__\":' block"
                    ));
                }
                "If" => {
                    // Check if this is the `if __name__ == '__main__':` pattern
                    if Self::is_main_guard(&node) {
                        // Lower module-level statements in a separate scope so variables
                        // declared here are not visible to functions
                        self.push_scope();
                        let body = ast_get_list!(node, "body");
                        for stmt in body.iter() {
                            module_level_stmts.extend(self.lower_stmt(&stmt)?);
                        }
                        self.pop_scope();
                    } else {
                        // Disallow other if statements at module level
                        let line = Self::get_line(&node);
                        return Err(self.syntax_error(
                            line,
                            "Module-level executable code must be inside 'if __name__ == \"__main__\":' block"
                        ));
                    }
                }
                _ => {
                    // Disallow any other executable code at module level
                    let line = Self::get_line(&node);
                    return Err(self.syntax_error(
                        line,
                        "Module-level executable code must be inside 'if __name__ == \"__main__\":' block"
                    ));
                }
            }
        }

        // Always synthesize a module main so codegen can reliably build the
        // C entry wrapper, even when a module has only definitions/imports.
        let main_func = self.build_synthetic_main(module_level_stmts);
        functions.insert(main_func.name.clone(), main_func);

        // Drain classes/functions discovered inside function/method bodies
        let deferred: Vec<_> = self.deferred_classes.drain(..).collect();
        for ci in &deferred {
            let tir_ci = self.lower_class_info(ci);
            classes.insert(tir_ci.name.clone(), tir_ci);
        }
        for func in self.deferred_functions.drain(..) {
            functions.insert(func.name.clone(), func);
        }

        for func in functions.values() {
            let func_type = Type::Function {
                params: func.params.iter().map(|p| p.ty.to_type()).collect(),
                return_type: Box::new(
                    func.return_type
                        .as_ref()
                        .map(|vt| vt.to_type())
                        .unwrap_or(Type::Unit),
                ),
            };
            self.symbol_table.insert(func.name.clone(), func_type);
        }

        let mut intrinsic_instances = self
            .intrinsic_instances
            .iter()
            .map(|((op, ty), tag)| crate::tir::IntrinsicInstance {
                op: *op,
                ty: ty.clone(),
                tag: *tag,
            })
            .collect::<Vec<_>>();
        intrinsic_instances.sort_by(|a, b| {
            a.tag
                .cmp(&b.tag)
                .then_with(|| a.ty.to_string().cmp(&b.ty.to_string()))
        });

        Ok(TirModule {
            functions,
            classes,
            intrinsic_instances,
        })
    }

    // ── utility helpers ───────────────────────────────────────────────

    fn get_line(node: &Bound<PyAny>) -> usize {
        ast_getattr!(node, "lineno")
            .extract::<usize>()
            .unwrap_or_default()
    }

    /// Check if an If statement is the `if __name__ == '__main__':` pattern
    fn is_main_guard(node: &Bound<PyAny>) -> bool {
        if ast_type_name!(node) != "If" {
            return false;
        }

        // Get the test expression
        let test = ast_getattr!(node, "test");

        // Check if it's a Compare node
        if ast_type_name!(test) != "Compare" {
            return false;
        }

        // Get left side - should be Name node with id='__name__'
        let left = ast_getattr!(test, "left");

        if ast_type_name!(left) != "Name" {
            return false;
        }

        let left_id = ast_get_string!(left, "id");

        if left_id != "__name__" {
            return false;
        }

        // Get ops - should be [Eq]
        let ops = ast_get_list!(test, "ops");

        if ops.len() != 1 {
            return false;
        }

        let op_type = ast_type_name!(ops.get_item(0).unwrap());
        if op_type != "Eq" {
            return false;
        }

        // Get comparators - should be a list with one Constant/Str with value '__main__'
        let comparators = ast_get_list!(test, "comparators");

        if comparators.len() != 1 {
            return false;
        }

        let comp = comparators.get_item(0).unwrap();
        let comp_type = ast_type_name!(comp);

        // Handle both Constant (Python 3.8+) and Str (older versions)
        let value = if comp_type == "Constant" {
            ast_getattr!(comp, "value")
        } else if comp_type == "Str" {
            ast_getattr!(comp, "s")
        } else {
            return false;
        };

        match value.extract::<String>() {
            Ok(v) => v == "__main__",
            Err(_) => false,
        }
    }

    fn mangle_name(&self, name: &str) -> String {
        format!("{}${}", self.current_module_name, name)
    }

    fn register_function_signature(
        &mut self,
        mangled_name: String,
        param_names: Vec<String>,
        default_values: Vec<Option<crate::tir::TirExpr>>,
    ) {
        self.function_signatures.insert(
            mangled_name,
            FunctionSignature {
                param_names,
                default_values,
            },
        );
    }

    fn ensure_supported_default_expr(&self, line: usize, expr: &crate::tir::TirExpr) -> Result<()> {
        use crate::tir::TirExprKind;

        match &expr.kind {
            TirExprKind::IntLiteral(_)
            | TirExprKind::FloatLiteral(_)
            | TirExprKind::StrLiteral(_)
            | TirExprKind::BytesLiteral(_) => Ok(()),

            // Unary operations
            TirExprKind::IntNeg(operand)
            | TirExprKind::FloatNeg(operand)
            | TirExprKind::Not(operand)
            | TirExprKind::BitNot(operand) => self.ensure_supported_default_expr(line, operand),

            // Binary operations
            TirExprKind::IntAdd(left, right)
            | TirExprKind::IntSub(left, right)
            | TirExprKind::IntMul(left, right)
            | TirExprKind::IntFloorDiv(left, right)
            | TirExprKind::IntMod(left, right)
            | TirExprKind::IntPow(left, right)
            | TirExprKind::FloatAdd(left, right)
            | TirExprKind::FloatSub(left, right)
            | TirExprKind::FloatMul(left, right)
            | TirExprKind::FloatDiv(left, right)
            | TirExprKind::FloatFloorDiv(left, right)
            | TirExprKind::FloatMod(left, right)
            | TirExprKind::FloatPow(left, right)
            | TirExprKind::BitAnd(left, right)
            | TirExprKind::BitOr(left, right)
            | TirExprKind::BitXor(left, right)
            | TirExprKind::LShift(left, right)
            | TirExprKind::RShift(left, right)
            | TirExprKind::IntEq(left, right)
            | TirExprKind::IntNotEq(left, right)
            | TirExprKind::IntLt(left, right)
            | TirExprKind::IntLtEq(left, right)
            | TirExprKind::IntGt(left, right)
            | TirExprKind::IntGtEq(left, right)
            | TirExprKind::FloatEq(left, right)
            | TirExprKind::FloatNotEq(left, right)
            | TirExprKind::FloatLt(left, right)
            | TirExprKind::FloatLtEq(left, right)
            | TirExprKind::FloatGt(left, right)
            | TirExprKind::FloatGtEq(left, right)
            | TirExprKind::BoolEq(left, right)
            | TirExprKind::BoolNotEq(left, right)
            | TirExprKind::LogicalAnd(left, right)
            | TirExprKind::LogicalOr(left, right) => {
                self.ensure_supported_default_expr(line, left)?;
                self.ensure_supported_default_expr(line, right)
            }

            TirExprKind::Cast { arg, .. } => self.ensure_supported_default_expr(line, arg),
            TirExprKind::Construct { args, .. } => {
                for elt in args {
                    self.ensure_supported_default_expr(line, elt)?;
                }
                Ok(())
            }
            TirExprKind::ListLiteral { elements, .. } => {
                for elt in elements {
                    self.ensure_supported_default_expr(line, elt)?;
                }
                Ok(())
            }
            _ => Err(self.syntax_error(
                line,
                "unsupported default argument expression (only constant expressions are supported)",
            )),
        }
    }

    /// Try to resolve an AST node as a dotted class/module path to a qualified class name.
    /// E.g., `Outer.Inner` → `module$Outer$Inner`, `mod.Class` → `mod$Class`
    fn try_resolve_class_path(&self, node: &Bound<PyAny>) -> Option<String> {
        match ast_type_name!(node).as_str() {
            "Name" => {
                let name = ast_get_string!(node, "id");
                match self.lookup(&name)? {
                    Type::Class(qualified) => Some(qualified.clone()),
                    Type::Module(mod_path) => Some(mod_path.clone()),
                    _ => None,
                }
            }
            "Attribute" => {
                let value_node = ast_getattr!(node, "value");
                let attr = ast_get_string!(node, "attr");
                let parent = self.try_resolve_class_path(&value_node)?;
                let candidate = format!("{}${}", parent, attr);
                if self.class_registry.contains_key(&candidate) {
                    Some(candidate)
                } else {
                    None
                }
            }
            _ => None,
        }
    }

    fn convert_return_type(&self, node: &Bound<PyAny>) -> Result<Type> {
        let returns = ast_getattr!(node, "returns");
        if returns.is_none() {
            Ok(Type::Unit)
        } else {
            self.convert_type_annotation(&returns)
        }
    }

    fn convert_type_annotation(&self, node: &Bound<PyAny>) -> Result<Type> {
        let node_type = ast_type_name!(node);
        match node_type.as_str() {
            "Name" => {
                let id = ast_get_string!(node, "id");
                match id.as_str() {
                    "int" => Ok(Type::Int),
                    "float" => Ok(Type::Float),
                    "bool" => Ok(Type::Bool),
                    "str" => Ok(Type::Str),
                    "bytes" => Ok(Type::Bytes),
                    "bytearray" => Ok(Type::ByteArray),
                    other => {
                        if let Some(ty) = self.lookup(other).cloned() {
                            match ty {
                                Type::Class(_) => Ok(ty),
                                Type::Module(ref mangled) => {
                                    // from-import of a class: `from mod import ClassName`
                                    if self.class_registry.contains_key(mangled) {
                                        Ok(Type::Class(mangled.clone()))
                                    } else {
                                        bail!("'{}' is not a type", other)
                                    }
                                }
                                _ => bail!("'{}' is not a type", other),
                            }
                        } else {
                            bail!("unsupported type `{}`", id)
                        }
                    }
                }
            }
            "Constant" => {
                let value = ast_getattr!(node, "value");
                if value.is_none() {
                    Ok(Type::Unit)
                } else if let Ok(s) = value.extract::<String>() {
                    // String literal as forward reference, e.g. -> "Countdown"
                    // First try simple class name lookup
                    if let Some(ty) = self.lookup(&s).cloned() {
                        if let Type::Class(_) = ty {
                            return Ok(ty);
                        }
                    }
                    if self.class_registry.contains_key(&s) {
                        return Ok(Type::Class(s));
                    }
                    // If not a simple name, parse as a type expression
                    // (e.g., "list[int]", "tuple[int, str]")
                    Python::attach(|py| {
                        let ast_module = PyModule::import(py, "ast").unwrap();
                        let parsed = ast_module.call_method1("parse", (s.as_str(),)).unwrap();
                        let body = ast_get_list!(&parsed, "body");
                        if body.len() != 1 {
                            bail!("unsupported forward reference type `{}`", s);
                        }
                        let expr_stmt = body.get_item(0)?;
                        if ast_type_name!(expr_stmt) != "Expr" {
                            bail!("unsupported forward reference type `{}`", s);
                        }
                        let inner_node = ast_getattr!(expr_stmt, "value");
                        self.convert_type_annotation(&inner_node)
                    })
                } else {
                    bail!("unsupported constant type annotation")
                }
            }
            "Attribute" => {
                if let Some(qualified) = self.try_resolve_class_path(node) {
                    if self.class_registry.contains_key(&qualified) {
                        return Ok(Type::Class(qualified));
                    }
                }
                bail!("unsupported type annotation: `{}`", node_type)
            }
            "Subscript" => {
                let value_node = ast_getattr!(node, "value");
                let slice_node = ast_getattr!(node, "slice");
                if ast_type_name!(value_node) != "Name" {
                    bail!("unsupported subscript type annotation");
                }
                let container_name = ast_get_string!(value_node, "id");
                match container_name.as_str() {
                    "list" => {
                        let inner_ty = self.convert_type_annotation(&slice_node)?;
                        match &inner_ty {
                            Type::Int
                            | Type::Float
                            | Type::Bool
                            | Type::Str
                            | Type::Bytes
                            | Type::ByteArray
                            | Type::Class(_)
                            | Type::List(_)
                            | Type::Dict(_, _)
                            | Type::Set(_)
                            | Type::Tuple(_) => {}
                            _ => bail!("unsupported list element type `{}`", inner_ty),
                        }
                        Ok(Type::List(Box::new(inner_ty)))
                    }
                    "dict" => {
                        if ast_type_name!(slice_node) != "Tuple" {
                            bail!("dict annotation must be `dict[key_type, value_type]`");
                        }
                        let elts = ast_get_list!(slice_node, "elts");
                        if elts.len() != 2 {
                            bail!("dict annotation must have exactly two type arguments");
                        }
                        let key_ty = self.convert_type_annotation(&elts.get_item(0)?)?;
                        let value_ty = self.convert_type_annotation(&elts.get_item(1)?)?;
                        if ValueType::from_type(&key_ty).is_none()
                            && !matches!(key_ty, Type::Tuple(_))
                        {
                            bail!("unsupported dict key type `{}`", key_ty);
                        }
                        if ValueType::from_type(&value_ty).is_none()
                            && !matches!(value_ty, Type::Tuple(_))
                        {
                            bail!("unsupported dict value type `{}`", value_ty);
                        }
                        Ok(Type::Dict(Box::new(key_ty), Box::new(value_ty)))
                    }
                    "set" => {
                        let inner_ty = self.convert_type_annotation(&slice_node)?;
                        if ValueType::from_type(&inner_ty).is_none()
                            && !matches!(inner_ty, Type::Tuple(_))
                        {
                            bail!("unsupported set element type `{}`", inner_ty);
                        }
                        Ok(Type::Set(Box::new(inner_ty)))
                    }
                    "tuple" => {
                        let element_types = if ast_type_name!(slice_node) == "Tuple" {
                            let elts = ast_get_list!(slice_node, "elts");
                            let mut out = Vec::with_capacity(elts.len());
                            for elt in elts.iter() {
                                out.push(self.convert_type_annotation(&elt)?);
                            }
                            out
                        } else {
                            vec![self.convert_type_annotation(&slice_node)?]
                        };
                        Ok(Type::Tuple(element_types))
                    }
                    _ => bail!("unsupported generic type `{}`", container_name),
                }
            }
            _ => bail!("unsupported type annotation: `{}`", node_type),
        }
    }

    fn convert_cmpop(node: &Bound<PyAny>) -> Result<CmpOp> {
        let op_type = ast_type_name!(node);
        match op_type.as_str() {
            "Eq" => Ok(CmpOp::Eq),
            "NotEq" => Ok(CmpOp::NotEq),
            "Lt" => Ok(CmpOp::Lt),
            "LtE" => Ok(CmpOp::LtEq),
            "Gt" => Ok(CmpOp::Gt),
            "GtE" => Ok(CmpOp::GtEq),
            "In" => Ok(CmpOp::In),
            "NotIn" => Ok(CmpOp::NotIn),
            "Is" => Ok(CmpOp::Is),
            "IsNot" => Ok(CmpOp::IsNot),
            _ => bail!("unsupported comparison operator: `{}`", op_type),
        }
    }

    fn convert_binop(node: &Bound<PyAny>) -> Result<RawBinOp> {
        let op_type = ast_type_name!(node);
        match op_type.as_str() {
            "Add" => Ok(RawBinOp::Arith(ArithBinOp::Add)),
            "Sub" => Ok(RawBinOp::Arith(ArithBinOp::Sub)),
            "Mult" => Ok(RawBinOp::Arith(ArithBinOp::Mul)),
            "Div" => Ok(RawBinOp::Arith(ArithBinOp::Div)),
            "FloorDiv" => Ok(RawBinOp::Arith(ArithBinOp::FloorDiv)),
            "Mod" => Ok(RawBinOp::Arith(ArithBinOp::Mod)),
            "Pow" => Ok(RawBinOp::Arith(ArithBinOp::Pow)),
            "BitAnd" => Ok(RawBinOp::Bitwise(BitwiseBinOp::BitAnd)),
            "BitOr" => Ok(RawBinOp::Bitwise(BitwiseBinOp::BitOr)),
            "BitXor" => Ok(RawBinOp::Bitwise(BitwiseBinOp::BitXor)),
            "LShift" => Ok(RawBinOp::Bitwise(BitwiseBinOp::LShift)),
            "RShift" => Ok(RawBinOp::Bitwise(BitwiseBinOp::RShift)),
            _ => bail!("unsupported binary operator: `{}`", op_type),
        }
    }

    fn convert_unaryop(op_type: &str) -> UnaryOpKind {
        match op_type {
            "USub" => UnaryOpKind::Neg,
            "UAdd" => UnaryOpKind::Pos,
            "Not" => UnaryOpKind::Not,
            "Invert" => UnaryOpKind::BitNot,
            _ => unreachable!("Python add new unary operator"),
        }
    }
}
