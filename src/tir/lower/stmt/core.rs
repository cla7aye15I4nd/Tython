use anyhow::Result;
use pyo3::prelude::*;
use std::collections::HashMap;

use crate::ast::{ClassInfo, Type};
use crate::tir::{builtin, CallResult, CallTarget, TirStmt, ValueType};
use crate::{ast_get_list, ast_get_string, ast_getattr, ast_type_name};

use crate::tir::lower::Lowering;

impl Lowering {
    pub(in crate::tir::lower) fn lower_stmt(
        &mut self,
        node: &Bound<PyAny>,
    ) -> Result<Vec<TirStmt>> {
        let node_type = ast_type_name!(node);
        let line = Self::get_line(node);

        let stmts = match node_type.as_str() {
            "FunctionDef" => self.handle_nested_function_def(node, line),
            "ClassDef" => self.handle_class_def_stmt(node, line),
            "AnnAssign" => self.handle_ann_assign(node, line),
            "Assign" => self.handle_assign(node, line),
            "AugAssign" => self.handle_aug_assign(node, line),
            "Return" => self.handle_return(node, line),
            "Expr" => self.handle_expr_stmt(node, line),
            "If" => {
                let raw_condition = self.lower_expr(&ast_getattr!(node, "test"))?;
                let condition = self.lower_truthy_to_bool(line, raw_condition, "if condition")?;
                let then_body = self.lower_block(&ast_get_list!(node, "body"))?;
                let else_body = self.lower_block(&ast_get_list!(node, "orelse"))?;
                Ok(vec![TirStmt::If {
                    condition,
                    then_body,
                    else_body,
                }])
            }
            "While" => {
                let raw_condition = self.lower_expr(&ast_getattr!(node, "test"))?;
                let condition =
                    self.lower_truthy_to_bool(line, raw_condition, "while condition")?;
                let body = self.lower_block(&ast_get_list!(node, "body"))?;
                let else_body = self.lower_block(&ast_get_list!(node, "orelse"))?;
                Ok(vec![TirStmt::While {
                    condition,
                    body,
                    else_body,
                }])
            }
            "For" => self.handle_for(node, line),
            "Break" => Ok(vec![TirStmt::Break]),
            "Continue" => Ok(vec![TirStmt::Continue]),
            "Assert" => self.handle_assert(node, line),
            "Try" => self.handle_try(node, line),
            "Raise" => self.handle_raise(node, line),
            "Pass" => Ok(vec![]), // pass statement generates no code
            _ => {
                Err(self.syntax_error(line, format!("unsupported statement type: `{}`", node_type)))
            }
        }?;

        // Drain any pre_stmts generated by list comprehensions
        let mut pre = std::mem::take(&mut self.pre_stmts);
        if pre.is_empty() {
            Ok(stmts)
        } else {
            pre.extend(stmts);
            Ok(pre)
        }
    }

    pub(in crate::tir::lower) fn handle_class_def_stmt(
        &mut self,
        node: &Bound<PyAny>,
        _line: usize,
    ) -> Result<Vec<TirStmt>> {
        let raw_name = ast_get_string!(node, "name");
        let fn_name = self.current_function_name.as_deref().unwrap_or("_");
        let qualified = format!("{}${}${}", self.current_module_name, fn_name, raw_name);

        self.class_registry.insert(
            qualified.clone(),
            ClassInfo {
                name: qualified.clone(),
                fields: Vec::new(),
                methods: HashMap::new(),
                field_map: HashMap::new(),
            },
        );
        self.declare(raw_name, Type::Class(qualified.clone()));

        let body = ast_get_list!(node, "body");
        self.discover_classes(&body, &qualified)?;
        self.collect_class_definition(node, &qualified)?;
        self.collect_classes(&body, &qualified)?;

        let (class_infos, methods) = self.lower_class_def(node, &qualified)?;
        self.deferred_classes.extend(class_infos);
        self.deferred_functions.extend(methods);

        Ok(vec![])
    }

    pub(in crate::tir::lower) fn handle_nested_function_def(
        &mut self,
        node: &Bound<PyAny>,
        line: usize,
    ) -> Result<Vec<TirStmt>> {
        use crate::tir::FunctionParam;

        let name = ast_get_string!(node, "name");

        // Build mangled name: module$enclosing$nested
        let enclosing = self
            .current_function_name
            .as_deref()
            .unwrap_or("_")
            .to_string();
        let mangled_name = format!("{}${}${}", self.current_module_name, enclosing, name);

        // Parse parameters
        let args_node = ast_getattr!(node, "args");
        let py_args = ast_get_list!(&args_node, "args");
        let default_values = self.lower_defaults_for_params(&args_node, line, &name)?;
        let mut param_types = Vec::new();
        let mut params = Vec::new();
        let mut param_names = Vec::new();
        let mut explicit_param_name_set = std::collections::HashSet::new();
        for arg in py_args.iter() {
            let param_name = ast_get_string!(arg, "arg");
            let annotation = ast_getattr!(arg, "annotation");
            if annotation.is_none() {
                return Err(self.syntax_error(
                    line,
                    format!(
                        "parameter `{}` in nested function `{}` requires a type annotation",
                        param_name, name
                    ),
                ));
            }
            let ty = self.convert_type_annotation(&annotation)?;
            let vty = Self::to_value_type(&ty);
            param_types.push(ty);
            param_names.push(param_name.clone());
            explicit_param_name_set.insert(param_name.clone());
            params.push(FunctionParam::new(param_name, vty));
        }

        let return_type_ast = self.convert_return_type(node)?;
        let return_type = Self::to_opt_value_type(&return_type_ast);

        // Declare the function in the current scope so it can be referenced
        let func_type = crate::ast::Type::Function {
            params: param_types,
            return_type: Box::new(return_type_ast.clone()),
        };
        self.declare(name.clone(), func_type);
        self.function_mangled_names
            .insert(name.clone(), mangled_name.clone());

        // Capture visible outer variables as hidden parameters for this lifted function.
        let mut captures: Vec<(String, Type)> = Vec::new();
        let mut seen = std::collections::HashSet::new();
        for scope in self.scopes.iter().rev() {
            for (k, v) in scope {
                if seen.contains(k) || explicit_param_name_set.contains(k) || k == &name {
                    continue;
                }
                // Skip function and class types - these are not runtime values that need capturing
                if matches!(
                    v,
                    crate::ast::Type::Function { .. } | crate::ast::Type::Class(_)
                ) {
                    continue;
                }
                // Only capture actual runtime variables
                if ValueType::from_type(v).is_some() {
                    seen.insert(k.clone());
                    captures.push((k.clone(), v.clone()));
                }
            }
        }
        for (cap_name, cap_ty) in &captures {
            params.push(FunctionParam::new(
                cap_name.clone(),
                Self::to_value_type(cap_ty),
            ));
        }
        self.nested_function_captures
            .insert(mangled_name.clone(), captures.clone());

        // Save enclosing function context
        let saved_return_type = self.current_return_type.take();
        let saved_function_name = self.current_function_name.take();

        // Set up context for the nested function
        self.current_return_type = Some(return_type_ast);
        self.current_function_name = Some(format!("{}.{}", enclosing, name));

        // Lower the body in a fresh scope (no closure capture)
        self.push_scope();
        for param in &params {
            self.declare(param.name.clone(), param.ty.to_type());
        }

        let body_list = ast_get_list!(node, "body");
        let mut tir_body = Vec::new();
        for stmt_node in body_list.iter() {
            let node_type = ast_type_name!(stmt_node);
            if node_type == "Import" || node_type == "ImportFrom" {
                return Err(self.syntax_error(
                    Self::get_line(&stmt_node),
                    "imports are only allowed at module top-level",
                ));
            }
            tir_body.extend(self.lower_stmt(&stmt_node)?);
        }

        self.pop_scope();

        // Restore enclosing function context
        self.current_return_type = saved_return_type;
        self.current_function_name = saved_function_name;

        // Push the nested function to deferred_functions (lifted to module level)
        self.deferred_functions.push(crate::tir::TirFunction {
            name: mangled_name.clone(),
            params,
            return_type,
            body: tir_body,
        });
        self.register_function_signature(mangled_name, param_names, default_values);

        // The nested function def produces no statements at the call site
        Ok(vec![])
    }

    pub(in crate::tir::lower) fn handle_return(
        &mut self,
        node: &Bound<PyAny>,
        line: usize,
    ) -> Result<Vec<TirStmt>> {
        if self.in_try_finally_depth > 0 {
            return Err(self.syntax_error(
                line,
                "`return` inside a try/except block with `finally` is not supported",
            ));
        }
        let value_node = ast_getattr!(node, "value");
        if value_node.is_none() {
            if let Some(ref expected) = self.current_return_type {
                if *expected != Type::Unit {
                    return Err(self.type_error(
                        line,
                        format!("return without value, but function expects `{}`", expected),
                    ));
                }
            }
            Ok(vec![TirStmt::Return(None)])
        } else {
            let tir_expr = self.lower_expr(&value_node)?;
            if let Some(ref expected) = self.current_return_type {
                if *expected != tir_expr.ty.to_type() {
                    return Err(self.type_error(
                        line,
                        format!(
                            "return type mismatch: expected `{}`, got `{}`",
                            expected, tir_expr.ty
                        ),
                    ));
                }
            }
            Ok(vec![TirStmt::Return(Some(tir_expr))])
        }
    }

    pub(in crate::tir::lower) fn handle_expr_stmt(
        &mut self,
        node: &Bound<PyAny>,
        line: usize,
    ) -> Result<Vec<TirStmt>> {
        let value_node = ast_getattr!(node, "value");

        // Skip Ellipsis (...) and docstrings (standalone string literals)
        if ast_type_name!(value_node) == "Constant" {
            let value = ast_getattr!(value_node, "value");

            // Check if this is Ellipsis (...)
            let type_name = value
                .get_type()
                .name()
                .map_err(|_| self.syntax_error(line, "failed to get constant type name"))?;

            if type_name == "ellipsis" {
                // Ellipsis statement - skip code generation
                return Ok(vec![]);
            }

            // Check if this is a standalone string literal (docstring)
            if value.is_instance_of::<pyo3::types::PyString>() {
                // Docstring - skip code generation
                return Ok(vec![]);
            }
        }

        if ast_type_name!(value_node) == "Call" {
            let func_node = ast_getattr!(value_node, "func");
            if ast_type_name!(func_node) == "Name" && ast_get_string!(func_node, "id") == "print" {
                return self.lower_print_stmt(&value_node);
            }

            let call_result = self.lower_call(&value_node, line)?;
            return match call_result {
                CallResult::Expr(expr) => Ok(vec![TirStmt::Expr(expr)]),
                CallResult::VoidStmt(stmt) => Ok(vec![*stmt]),
            };
        }

        Ok(vec![TirStmt::Expr(self.lower_expr(&value_node)?)])
    }

    pub(in crate::tir::lower) fn handle_assert(
        &mut self,
        node: &Bound<PyAny>,
        line: usize,
    ) -> Result<Vec<TirStmt>> {
        let test_node = ast_getattr!(node, "test");
        let condition = self.lower_expr(&test_node)?;
        if !matches!(
            condition.ty,
            ValueType::Bool
                | ValueType::Int
                | ValueType::Float
                | ValueType::Str
                | ValueType::Bytes
                | ValueType::ByteArray
                | ValueType::List(_)
                | ValueType::Tuple(_)
        ) {
            return Err(self.type_error(line, format!("cannot use `{}` in assert", condition.ty)));
        }
        let bool_condition = self.lower_truthy_to_bool(line, condition, "assert")?;

        Ok(vec![TirStmt::VoidCall {
            target: CallTarget::Builtin(builtin::BuiltinFn::Assert),
            args: vec![bool_condition],
        }])
    }
}
