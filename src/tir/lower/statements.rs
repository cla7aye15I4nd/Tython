use anyhow::Result;
use pyo3::prelude::*;
use std::collections::HashMap;

use crate::ast::{ClassInfo, Type};
use crate::tir::{
    builtin, ArithBinOp, CallResult, CallTarget, ExceptClause, RawBinOp, TirExpr, TirExprKind,
    TirStmt, ValueType,
};
use crate::{ast_get_list, ast_get_string, ast_getattr, ast_type_name};

use super::Lowering;

impl Lowering {
    pub(super) fn lower_stmt(&mut self, node: &Bound<PyAny>) -> Result<Vec<TirStmt>> {
        let node_type = ast_type_name!(node);
        let line = Self::get_line(node);

        let stmts = match node_type.as_str() {
            "FunctionDef" => self.handle_nested_function_def(node, line),
            "ClassDef" => self.handle_class_def_stmt(node, line),
            "AnnAssign" => self.handle_ann_assign(node, line),
            "Assign" => self.handle_assign(node, line),
            "AugAssign" => self.handle_aug_assign(node, line),
            "Return" => self.handle_return(node, line),
            "Expr" => self.handle_expr_stmt(node, line),
            "If" => {
                let raw_condition = self.lower_expr(&ast_getattr!(node, "test"))?;
                let condition = self.lower_truthy_to_bool(line, raw_condition, "if condition")?;
                let then_body = self.lower_block(&ast_get_list!(node, "body"))?;
                let else_body = self.lower_block(&ast_get_list!(node, "orelse"))?;
                Ok(vec![TirStmt::If {
                    condition,
                    then_body,
                    else_body,
                }])
            }
            "While" => {
                let raw_condition = self.lower_expr(&ast_getattr!(node, "test"))?;
                let condition =
                    self.lower_truthy_to_bool(line, raw_condition, "while condition")?;
                let body = self.lower_block(&ast_get_list!(node, "body"))?;
                let else_body = self.lower_block(&ast_get_list!(node, "orelse"))?;
                Ok(vec![TirStmt::While {
                    condition,
                    body,
                    else_body,
                }])
            }
            "For" => self.handle_for(node, line),
            "Break" => Ok(vec![TirStmt::Break]),
            "Continue" => Ok(vec![TirStmt::Continue]),
            "Assert" => self.handle_assert(node, line),
            "Try" => self.handle_try(node, line),
            "Raise" => self.handle_raise(node, line),
            "Pass" => Ok(vec![]), // pass statement generates no code
            _ => {
                Err(self.syntax_error(line, format!("unsupported statement type: `{}`", node_type)))
            }
        }?;

        // Drain any pre_stmts generated by list comprehensions
        let mut pre = std::mem::take(&mut self.pre_stmts);
        if pre.is_empty() {
            Ok(stmts)
        } else {
            pre.extend(stmts);
            Ok(pre)
        }
    }

    fn handle_class_def_stmt(&mut self, node: &Bound<PyAny>, _line: usize) -> Result<Vec<TirStmt>> {
        let raw_name = ast_get_string!(node, "name");
        let fn_name = self.current_function_name.as_deref().unwrap_or("_");
        let qualified = format!("{}${}${}", self.current_module_name, fn_name, raw_name);

        self.class_registry.insert(
            qualified.clone(),
            ClassInfo {
                name: qualified.clone(),
                fields: Vec::new(),
                methods: HashMap::new(),
                field_map: HashMap::new(),
            },
        );
        self.declare(raw_name, Type::Class(qualified.clone()));

        let body = ast_get_list!(node, "body");
        self.discover_classes(&body, &qualified)?;
        self.collect_class_definition(node, &qualified)?;
        self.collect_classes(&body, &qualified)?;

        let (class_infos, methods) = self.lower_class_def(node, &qualified)?;
        self.deferred_classes.extend(class_infos);
        self.deferred_functions.extend(methods);

        Ok(vec![])
    }

    fn handle_nested_function_def(
        &mut self,
        node: &Bound<PyAny>,
        line: usize,
    ) -> Result<Vec<TirStmt>> {
        use crate::tir::FunctionParam;

        let name = ast_get_string!(node, "name");

        // Build mangled name: module$enclosing$nested
        let enclosing = self
            .current_function_name
            .as_deref()
            .unwrap_or("_")
            .to_string();
        let mangled_name = format!("{}${}${}", self.current_module_name, enclosing, name);

        // Parse parameters
        let args_node = ast_getattr!(node, "args");
        let py_args = ast_get_list!(&args_node, "args");
        let default_values = self.lower_defaults_for_params(&args_node, line, &name)?;
        let mut param_types = Vec::new();
        let mut params = Vec::new();
        let mut param_names = Vec::new();
        let mut explicit_param_name_set = std::collections::HashSet::new();
        for arg in py_args.iter() {
            let param_name = ast_get_string!(arg, "arg");
            let annotation = ast_getattr!(arg, "annotation");
            if annotation.is_none() {
                return Err(self.syntax_error(
                    line,
                    format!(
                        "parameter `{}` in nested function `{}` requires a type annotation",
                        param_name, name
                    ),
                ));
            }
            let ty = self.convert_type_annotation(&annotation)?;
            let vty = Self::to_value_type(&ty);
            param_types.push(ty);
            param_names.push(param_name.clone());
            explicit_param_name_set.insert(param_name.clone());
            params.push(FunctionParam::new(param_name, vty));
        }

        let return_type_ast = self.convert_return_type(node)?;
        let return_type = Self::to_opt_value_type(&return_type_ast);

        // Declare the function in the current scope so it can be referenced
        let func_type = crate::ast::Type::Function {
            params: param_types,
            return_type: Box::new(return_type_ast.clone()),
        };
        self.declare(name.clone(), func_type);
        self.function_mangled_names
            .insert(name.clone(), mangled_name.clone());

        // Capture visible outer variables as hidden parameters for this lifted function.
        let mut captures: Vec<(String, Type)> = Vec::new();
        let mut seen = std::collections::HashSet::new();
        for scope in self.scopes.iter().rev() {
            for (k, v) in scope {
                if seen.contains(k) || explicit_param_name_set.contains(k) || k == &name {
                    continue;
                }
                // Skip function and class types - these are not runtime values that need capturing
                if matches!(
                    v,
                    crate::ast::Type::Function { .. } | crate::ast::Type::Class(_)
                ) {
                    continue;
                }
                // Only capture actual runtime variables
                if ValueType::from_type(v).is_some() {
                    seen.insert(k.clone());
                    captures.push((k.clone(), v.clone()));
                }
            }
        }
        for (cap_name, cap_ty) in &captures {
            params.push(FunctionParam::new(
                cap_name.clone(),
                Self::to_value_type(cap_ty),
            ));
        }
        self.nested_function_captures
            .insert(mangled_name.clone(), captures.clone());

        // Save enclosing function context
        let saved_return_type = self.current_return_type.take();
        let saved_function_name = self.current_function_name.take();

        // Set up context for the nested function
        self.current_return_type = Some(return_type_ast);
        self.current_function_name = Some(format!("{}.{}", enclosing, name));

        // Lower the body in a fresh scope (no closure capture)
        self.push_scope();
        for param in &params {
            self.declare(param.name.clone(), param.ty.to_type());
        }

        let body_list = ast_get_list!(node, "body");
        let mut tir_body = Vec::new();
        for stmt_node in body_list.iter() {
            let node_type = ast_type_name!(stmt_node);
            if node_type == "Import" || node_type == "ImportFrom" {
                return Err(self.syntax_error(
                    Self::get_line(&stmt_node),
                    "imports are only allowed at module top-level",
                ));
            }
            tir_body.extend(self.lower_stmt(&stmt_node)?);
        }

        self.pop_scope();

        // Restore enclosing function context
        self.current_return_type = saved_return_type;
        self.current_function_name = saved_function_name;

        // Push the nested function to deferred_functions (lifted to module level)
        self.deferred_functions.push(crate::tir::TirFunction {
            name: mangled_name.clone(),
            params,
            return_type,
            body: tir_body,
        });
        self.register_function_signature(mangled_name, param_names, default_values);

        // The nested function def produces no statements at the call site
        Ok(vec![])
    }

    fn handle_ann_assign(&mut self, node: &Bound<PyAny>, line: usize) -> Result<Vec<TirStmt>> {
        let target_node = ast_getattr!(node, "target");
        if ast_type_name!(target_node) != "Name" {
            return Err(self.syntax_error(line, "only simple variable assignments are supported"));
        }
        let target = ast_get_string!(target_node, "id");

        let annotation = ast_getattr!(node, "annotation");
        let annotated_ty = (!annotation.is_none())
            .then(|| self.convert_type_annotation(&annotation))
            .transpose()?;

        let value_node = ast_getattr!(node, "value");

        // Handle empty list literal `[]` with type annotation
        if ast_type_name!(value_node) == "List" {
            let elts = ast_get_list!(value_node, "elts");
            if elts.is_empty() {
                let list_ty = annotated_ty.ok_or_else(|| {
                    self.syntax_error(line, "empty list literal `[]` requires a type annotation")
                })?;
                let inner_ty = match &list_ty {
                    Type::List(inner) => Self::to_value_type(inner),
                    _ => {
                        return Err(self.type_error(
                            line,
                            format!("type mismatch: expected `list[...]`, got `{}`", list_ty),
                        ))
                    }
                };
                let vty = ValueType::List(Box::new(inner_ty.clone()));
                self.declare(target.clone(), list_ty);
                return Ok(vec![TirStmt::Let {
                    name: target,
                    ty: vty.clone(),
                    value: TirExpr {
                        kind: TirExprKind::ListLiteral {
                            element_type: inner_ty,
                            elements: vec![],
                        },
                        ty: vty,
                    },
                }]);
            }
        }

        // Handle empty dict literal `{}` with type annotation
        if ast_type_name!(value_node) == "Dict" {
            let keys = ast_get_list!(value_node, "keys");
            if keys.is_empty() {
                let dict_ty = annotated_ty.ok_or_else(|| {
                    self.syntax_error(line, "empty dict literal `{}` requires a type annotation")
                })?;
                let (key_ty, value_ty) = match &dict_ty {
                    Type::Dict(key, value) => {
                        (Self::to_value_type(key), Self::to_value_type(value))
                    }
                    _ => {
                        return Err(self.type_error(
                            line,
                            format!(
                                "type mismatch: expected `dict[..., ...]`, got `{}`",
                                dict_ty
                            ),
                        ))
                    }
                };
                let vty = ValueType::Dict(Box::new(key_ty), Box::new(value_ty));
                self.declare(target.clone(), dict_ty);
                return Ok(vec![TirStmt::Let {
                    name: target,
                    ty: vty.clone(),
                    value: TirExpr {
                        kind: TirExprKind::ExternalCall {
                            func: builtin::BuiltinFn::DictEmpty,
                            args: vec![],
                        },
                        ty: vty,
                    },
                }]);
            }
        }

        // Handle empty set constructor set() with type annotation
        if ast_type_name!(value_node) == "Call" {
            let func_node_inner = ast_getattr!(value_node, "func");
            if ast_type_name!(func_node_inner) == "Name"
                && ast_get_string!(func_node_inner, "id") == "set"
                && ast_get_list!(value_node, "args").is_empty()
            {
                let set_ty = annotated_ty.ok_or_else(|| {
                    self.syntax_error(line, "set() requires a type annotation in this context")
                })?;
                let inner_ty = match &set_ty {
                    Type::Set(inner) => Self::to_value_type(inner),
                    _ => {
                        return Err(self.type_error(
                            line,
                            format!("type mismatch: expected `set[...]`, got `{}`", set_ty),
                        ))
                    }
                };
                let vty = ValueType::Set(Box::new(inner_ty));
                self.declare(target.clone(), set_ty);
                return Ok(vec![TirStmt::Let {
                    name: target,
                    ty: vty.clone(),
                    value: TirExpr {
                        kind: TirExprKind::ExternalCall {
                            func: builtin::BuiltinFn::SetEmpty,
                            args: vec![],
                        },
                        ty: vty,
                    },
                }]);
            }
        }

        // Handle tuple(genexpr) with type annotation
        if ast_type_name!(value_node) == "Call" {
            let func_node_inner = ast_getattr!(value_node, "func");
            if ast_type_name!(func_node_inner) == "Name"
                && ast_get_string!(func_node_inner, "id") == "tuple"
            {
                let call_args = ast_get_list!(value_node, "args");
                if call_args.len() == 1 {
                    let arg0 = call_args.get_item(0).unwrap();
                    if ast_type_name!(arg0) == "GeneratorExp" {
                        let tuple_ty = annotated_ty.clone().ok_or_else(|| {
                            self.syntax_error(line, "tuple(genexpr) requires a type annotation")
                        })?;
                        let element_types = match &tuple_ty {
                            Type::Tuple(elements) => {
                                elements.iter().map(Self::to_value_type).collect::<Vec<_>>()
                            }
                            _ => {
                                return Err(self.type_error(
                                    line,
                                    format!(
                                    "expected tuple type annotation for tuple(genexpr), got `{}`",
                                    tuple_ty
                                ),
                                ))
                            }
                        };

                        let elt_node = ast_getattr!(arg0, "elt");
                        let generators = ast_get_list!(arg0, "generators");
                        let list_expr = self.lower_comp_impl(&elt_node, &generators, line)?;

                        // Build tuple elements: list_get(list, 0), list_get(list, 1), ...
                        let mut tuple_elements = Vec::new();
                        for (i, elem_ty) in element_types.iter().enumerate() {
                            tuple_elements.push(TirExpr {
                                kind: TirExprKind::ExternalCall {
                                    func: builtin::BuiltinFn::ListGet,
                                    args: vec![
                                        list_expr.clone(),
                                        TirExpr {
                                            kind: TirExprKind::IntLiteral(i as i64),
                                            ty: ValueType::Int,
                                        },
                                    ],
                                },
                                ty: elem_ty.clone(),
                            });
                        }

                        let vty = ValueType::Tuple(element_types.clone());
                        self.declare(target.clone(), tuple_ty);

                        return Ok(vec![TirStmt::Let {
                            name: target,
                            ty: vty.clone(),
                            value: TirExpr {
                                kind: TirExprKind::TupleLiteral {
                                    elements: tuple_elements,
                                    element_types,
                                },
                                ty: vty,
                            },
                        }]);
                    }
                }
            }
        }

        let saved_empty_list_hint = self.empty_list_hint.clone();
        if let Some(Type::List(inner)) = &annotated_ty {
            self.empty_list_hint = Some(Self::to_value_type(inner));
        }
        let tir_value = self.lower_expr(&value_node)?;
        self.empty_list_hint = saved_empty_list_hint;

        let tir_value_ast_ty = tir_value.ty.to_type();
        if let Some(ref ann_ty) = annotated_ty {
            if ann_ty != &tir_value_ast_ty {
                return Err(self.type_error(
                    line,
                    format!(
                        "type mismatch: expected `{}`, got `{}`",
                        ann_ty, tir_value_ast_ty
                    ),
                ));
            }
        }

        let var_type = annotated_ty.unwrap_or(tir_value_ast_ty);
        self.declare(target.clone(), var_type.clone());

        Ok(vec![TirStmt::Let {
            name: target,
            ty: Self::to_value_type(&var_type),
            value: tir_value,
        }])
    }

    fn handle_assign(&mut self, node: &Bound<PyAny>, line: usize) -> Result<Vec<TirStmt>> {
        let targets_list = ast_get_list!(node, "targets");
        if targets_list.len() != 1 {
            return Err(self.syntax_error(line, "multiple assignment targets are not supported"));
        }

        let target_node = targets_list.get_item(0)?;
        match ast_type_name!(target_node).as_str() {
            "Name" => {
                let target = ast_get_string!(target_node, "id");
                let value_node = ast_getattr!(node, "value");
                let saved_empty_list_hint = self.empty_list_hint.clone();
                if let Some(Type::List(inner)) = self.lookup(&target).cloned() {
                    self.empty_list_hint = Some(Self::to_value_type(&inner));
                }
                let tir_value = self.lower_expr(&value_node)?;
                self.empty_list_hint = saved_empty_list_hint;
                let var_type = tir_value.ty.to_type();
                self.declare(target.clone(), var_type);

                Ok(vec![TirStmt::Let {
                    name: target,
                    ty: tir_value.ty.clone(),
                    value: tir_value,
                }])
            }
            "Attribute" => self.lower_attribute_assign(&target_node, node, line),
            "Subscript" => self.lower_subscript_assign(&target_node, node, line),
            _ => Err(self.syntax_error(
                line,
                "only variable, attribute, or subscript assignments are supported",
            )),
        }
    }

    fn handle_aug_assign(&mut self, node: &Bound<PyAny>, line: usize) -> Result<Vec<TirStmt>> {
        let target_node = ast_getattr!(node, "target");
        match ast_type_name!(target_node).as_str() {
            "Name" => {
                let target = ast_get_string!(target_node, "id");

                let target_ty = self.lookup(&target).cloned().ok_or_else(|| {
                    self.name_error(line, format!("undefined variable `{}`", target))
                })?;

                let op = Self::convert_binop(&ast_getattr!(node, "op"))?;
                let value_expr = self.lower_expr(&ast_getattr!(node, "value"))?;

                if op == RawBinOp::Arith(ArithBinOp::Div) && target_ty == Type::Int {
                    return Err(self.type_error(
                        line,
                        format!("`/=` on `int` variable `{}` would change type to `float`; use `//=` for integer division", target),
                    ));
                }

                let target_ref = TirExpr {
                    kind: TirExprKind::Var(target.clone()),
                    ty: Self::to_value_type(&target_ty),
                };

                let binop_expr = self.resolve_binop(line, op, target_ref, value_expr)?;
                self.declare(target.clone(), binop_expr.ty.to_type());

                Ok(vec![TirStmt::Let {
                    name: target,
                    ty: binop_expr.ty.clone(),
                    value: binop_expr,
                }])
            }
            "Attribute" => self.lower_attribute_aug_assign(&target_node, node, line),
            "Subscript" => self.lower_subscript_aug_assign(&target_node, node, line),
            _ => Err(self.syntax_error(
                line,
                "only variable, attribute, or subscript augmented assignments are supported",
            )),
        }
    }

    fn handle_return(&mut self, node: &Bound<PyAny>, line: usize) -> Result<Vec<TirStmt>> {
        if self.in_try_finally_depth > 0 {
            return Err(self.syntax_error(
                line,
                "`return` inside a try/except block with `finally` is not supported",
            ));
        }
        let value_node = ast_getattr!(node, "value");
        if value_node.is_none() {
            if let Some(ref expected) = self.current_return_type {
                if *expected != Type::Unit {
                    return Err(self.type_error(
                        line,
                        format!("return without value, but function expects `{}`", expected),
                    ));
                }
            }
            Ok(vec![TirStmt::Return(None)])
        } else {
            let tir_expr = self.lower_expr(&value_node)?;
            if let Some(ref expected) = self.current_return_type {
                if *expected != tir_expr.ty.to_type() {
                    return Err(self.type_error(
                        line,
                        format!(
                            "return type mismatch: expected `{}`, got `{}`",
                            expected, tir_expr.ty
                        ),
                    ));
                }
            }
            Ok(vec![TirStmt::Return(Some(tir_expr))])
        }
    }

    fn handle_expr_stmt(&mut self, node: &Bound<PyAny>, line: usize) -> Result<Vec<TirStmt>> {
        let value_node = ast_getattr!(node, "value");

        // Skip Ellipsis (...) and docstrings (standalone string literals)
        if ast_type_name!(value_node) == "Constant" {
            let value = ast_getattr!(value_node, "value");

            // Check if this is Ellipsis (...)
            let type_name = value
                .get_type()
                .name()
                .map_err(|_| self.syntax_error(line, "failed to get constant type name"))?;

            if type_name == "ellipsis" {
                // Ellipsis statement - skip code generation
                return Ok(vec![]);
            }

            // Check if this is a standalone string literal (docstring)
            if value.is_instance_of::<pyo3::types::PyString>() {
                // Docstring - skip code generation
                return Ok(vec![]);
            }
        }

        if ast_type_name!(value_node) == "Call" {
            let func_node = ast_getattr!(value_node, "func");
            if ast_type_name!(func_node) == "Name" && ast_get_string!(func_node, "id") == "print" {
                return self.lower_print_stmt(&value_node);
            }

            let call_result = self.lower_call(&value_node, line)?;
            return match call_result {
                CallResult::Expr(expr) => Ok(vec![TirStmt::Expr(expr)]),
                CallResult::VoidStmt(stmt) => Ok(vec![*stmt]),
            };
        }

        Ok(vec![TirStmt::Expr(self.lower_expr(&value_node)?)])
    }

    fn handle_assert(&mut self, node: &Bound<PyAny>, line: usize) -> Result<Vec<TirStmt>> {
        let test_node = ast_getattr!(node, "test");
        let condition = self.lower_expr(&test_node)?;
        if !matches!(
            condition.ty,
            ValueType::Bool
                | ValueType::Int
                | ValueType::Float
                | ValueType::Str
                | ValueType::Bytes
                | ValueType::ByteArray
                | ValueType::List(_)
                | ValueType::Tuple(_)
        ) {
            return Err(self.type_error(line, format!("cannot use `{}` in assert", condition.ty)));
        }
        let bool_condition = self.lower_truthy_to_bool(line, condition, "assert")?;

        Ok(vec![TirStmt::VoidCall {
            target: CallTarget::Builtin(builtin::BuiltinFn::Assert),
            args: vec![bool_condition],
        }])
    }

    fn handle_for(&mut self, node: &Bound<PyAny>, line: usize) -> Result<Vec<TirStmt>> {
        let target_node = ast_getattr!(node, "target");
        let target_type = ast_type_name!(target_node);
        if target_type == "Tuple" {
            let target_names = self.extract_for_target_tuple_names(line, &target_node)?;
            let iter_node = ast_getattr!(node, "iter");
            if ast_type_name!(iter_node) == "Call" {
                let func_node = ast_getattr!(iter_node, "func");
                if ast_type_name!(func_node) == "Name" {
                    let func_name = ast_get_string!(func_node, "id");
                    if func_name == "zip" {
                        return self.handle_for_zip_unpack(node, line, &target_names, &iter_node);
                    }
                    if func_name == "enumerate" {
                        return self.handle_for_enumerate_unpack(
                            node,
                            line,
                            &target_names,
                            &iter_node,
                        );
                    }
                }
            }
            return Err(self.syntax_error(
                line,
                "tuple-unpack for-loop target is only supported with zip(...) or enumerate(...)",
            ));
        }
        if target_type != "Name" {
            return Err(self.syntax_error(line, "for-loop target must be a variable or tuple"));
        }
        let loop_var = ast_get_string!(target_node, "id");

        let iter_node = ast_getattr!(node, "iter");

        // Check for range(...) first
        if ast_type_name!(iter_node) == "Call" {
            let func_node = ast_getattr!(iter_node, "func");
            if ast_type_name!(func_node) == "Name" && ast_get_string!(func_node, "id") == "range" {
                return self.handle_for_range(node, line, &loop_var, &iter_node);
            }
        }

        // General iterable: evaluate the iterator expression
        let iterable_expr = self.lower_expr(&iter_node)?;

        match iterable_expr.ty.clone() {
            ValueType::List(inner) => {
                self.handle_for_list(node, line, &loop_var, iterable_expr, (*inner).clone())
            }
            ValueType::Str => self.handle_for_str(node, line, &loop_var, iterable_expr),
            ValueType::Bytes => self.handle_for_bytes(node, line, &loop_var, iterable_expr),
            ValueType::ByteArray => self.handle_for_bytearray(node, line, &loop_var, iterable_expr),
            ValueType::Class(class_name) => {
                self.handle_for_class_iter(node, line, &loop_var, iterable_expr, &class_name)
            }
            ValueType::Tuple(ref elements) => {
                let first = elements
                    .first()
                    .ok_or_else(|| self.type_error(line, "cannot iterate over empty tuple"))?;
                if elements.iter().any(|ty| ty != first) {
                    return Err(self.type_error(
                        line,
                        "for-in over tuple requires all elements to have the same type",
                    ));
                }
                let elem_ty = first.clone();
                let tuple_len = elements.len();
                self.handle_for_tuple(node, line, &loop_var, iterable_expr, elem_ty, tuple_len)
            }
            other => Err(self.type_error(line, format!("cannot iterate over `{}`", other))),
        }
    }

    fn extract_for_target_tuple_names(
        &self,
        line: usize,
        target_node: &Bound<PyAny>,
    ) -> Result<Vec<String>> {
        let elts = ast_get_list!(target_node, "elts");
        if elts.is_empty() {
            return Err(self.syntax_error(line, "empty tuple target in for-loop is invalid"));
        }
        let mut names = Vec::with_capacity(elts.len());
        for elt in elts.iter() {
            if ast_type_name!(elt) != "Name" {
                return Err(self.syntax_error(
                    line,
                    "for-loop tuple target must contain only simple variable names",
                ));
            }
            names.push(ast_get_string!(elt, "id"));
        }
        Ok(names)
    }

    fn make_list_get_expr(
        &self,
        list_var: &str,
        list_ty: ValueType,
        idx_var: &str,
        elem_ty: ValueType,
    ) -> TirExpr {
        TirExpr {
            kind: TirExprKind::ExternalCall {
                func: builtin::BuiltinFn::ListGet,
                args: vec![
                    TirExpr {
                        kind: TirExprKind::Var(list_var.to_string()),
                        ty: list_ty,
                    },
                    TirExpr {
                        kind: TirExprKind::Var(idx_var.to_string()),
                        ty: ValueType::Int,
                    },
                ],
            },
            ty: elem_ty,
        }
    }

    fn handle_for_zip_unpack(
        &mut self,
        node: &Bound<PyAny>,
        line: usize,
        target_names: &[String],
        iter_node: &Bound<PyAny>,
    ) -> Result<Vec<TirStmt>> {
        if target_names.len() != 2 {
            return Err(self.syntax_error(
                line,
                "zip(...) unpack currently requires exactly two target variables",
            ));
        }
        let args = ast_get_list!(iter_node, "args");
        if args.len() != 2 {
            return Err(self.type_error(
                line,
                format!("zip() expects 2 arguments, got {}", args.len()),
            ));
        }

        let left = self.lower_expr(&args.get_item(0)?)?;
        let right = self.lower_expr(&args.get_item(1)?)?;
        let left_ty = left.ty.clone();
        let right_ty = right.ty.clone();
        let (left_elem, right_elem) = match (&left.ty, &right.ty) {
            (ValueType::List(a), ValueType::List(b)) => ((**a).clone(), (**b).clone()),
            _ => {
                return Err(self.type_error(
                    line,
                    "zip() in for-loop unpack currently requires list arguments",
                ))
            }
        };

        let left_var = self.fresh_internal("zip_left");
        let right_var = self.fresh_internal("zip_right");
        let len_left_var = self.fresh_internal("zip_len_left");
        let len_right_var = self.fresh_internal("zip_len_right");
        let start_var = self.fresh_internal("zip_start");
        let stop_var = self.fresh_internal("zip_stop");
        let step_var = self.fresh_internal("zip_step");
        let idx_var = self.fresh_internal("zip_idx");

        self.declare(left_var.clone(), left.ty.to_type());
        self.declare(right_var.clone(), right.ty.to_type());
        self.declare(len_left_var.clone(), Type::Int);
        self.declare(len_right_var.clone(), Type::Int);
        self.declare(start_var.clone(), Type::Int);
        self.declare(stop_var.clone(), Type::Int);
        self.declare(step_var.clone(), Type::Int);
        self.declare(idx_var.clone(), Type::Int);
        self.declare(target_names[0].clone(), left_elem.to_type());
        self.declare(target_names[1].clone(), right_elem.to_type());

        let mut body = vec![
            TirStmt::Let {
                name: target_names[0].clone(),
                ty: left_elem.clone(),
                value: self.make_list_get_expr(&left_var, left.ty.clone(), &idx_var, left_elem),
            },
            TirStmt::Let {
                name: target_names[1].clone(),
                ty: right_elem.clone(),
                value: self.make_list_get_expr(&right_var, right.ty.clone(), &idx_var, right_elem),
            },
        ];
        body.extend(self.lower_block_in_current_scope(&ast_get_list!(node, "body"))?);
        let else_body = self.lower_block_in_current_scope(&ast_get_list!(node, "orelse"))?;

        Ok(vec![
            TirStmt::Let {
                name: left_var.clone(),
                ty: left_ty.clone(),
                value: left,
            },
            TirStmt::Let {
                name: right_var.clone(),
                ty: right_ty.clone(),
                value: right,
            },
            TirStmt::Let {
                name: len_left_var.clone(),
                ty: ValueType::Int,
                value: TirExpr {
                    kind: TirExprKind::ExternalCall {
                        func: builtin::BuiltinFn::ListLen,
                        args: vec![TirExpr {
                            kind: TirExprKind::Var(left_var),
                            ty: left_ty,
                        }],
                    },
                    ty: ValueType::Int,
                },
            },
            TirStmt::Let {
                name: len_right_var.clone(),
                ty: ValueType::Int,
                value: TirExpr {
                    kind: TirExprKind::ExternalCall {
                        func: builtin::BuiltinFn::ListLen,
                        args: vec![TirExpr {
                            kind: TirExprKind::Var(right_var),
                            ty: right_ty,
                        }],
                    },
                    ty: ValueType::Int,
                },
            },
            TirStmt::Let {
                name: start_var.clone(),
                ty: ValueType::Int,
                value: TirExpr {
                    kind: TirExprKind::IntLiteral(0),
                    ty: ValueType::Int,
                },
            },
            TirStmt::Let {
                name: stop_var.clone(),
                ty: ValueType::Int,
                value: TirExpr {
                    kind: TirExprKind::ExternalCall {
                        func: builtin::BuiltinFn::MinInt,
                        args: vec![
                            TirExpr {
                                kind: TirExprKind::Var(len_left_var),
                                ty: ValueType::Int,
                            },
                            TirExpr {
                                kind: TirExprKind::Var(len_right_var),
                                ty: ValueType::Int,
                            },
                        ],
                    },
                    ty: ValueType::Int,
                },
            },
            TirStmt::Let {
                name: step_var.clone(),
                ty: ValueType::Int,
                value: TirExpr {
                    kind: TirExprKind::IntLiteral(1),
                    ty: ValueType::Int,
                },
            },
            TirStmt::ForRange {
                loop_var: idx_var,
                start_var,
                stop_var,
                step_var,
                body,
                else_body,
            },
        ])
    }

    fn handle_for_enumerate_unpack(
        &mut self,
        node: &Bound<PyAny>,
        line: usize,
        target_names: &[String],
        iter_node: &Bound<PyAny>,
    ) -> Result<Vec<TirStmt>> {
        if target_names.len() != 2 {
            return Err(self.syntax_error(
                line,
                "enumerate(...) unpack currently requires exactly two target variables",
            ));
        }
        let args = ast_get_list!(iter_node, "args");
        if args.len() != 1 {
            return Err(self.type_error(
                line,
                format!("enumerate() expects 1 argument, got {}", args.len()),
            ));
        }
        let list_expr = self.lower_expr(&args.get_item(0)?)?;
        let elem_ty = match &list_expr.ty {
            ValueType::List(inner) => (**inner).clone(),
            _ => {
                return Err(self.type_error(
                    line,
                    "enumerate() in for-loop unpack requires a list argument",
                ))
            }
        };

        let list_var = self.fresh_internal("enum_list");
        let len_var = self.fresh_internal("enum_len");
        let start_var = self.fresh_internal("enum_start");
        let stop_var = self.fresh_internal("enum_stop");
        let step_var = self.fresh_internal("enum_step");
        let idx_var = self.fresh_internal("enum_idx");

        self.declare(list_var.clone(), list_expr.ty.to_type());
        self.declare(len_var.clone(), Type::Int);
        self.declare(start_var.clone(), Type::Int);
        self.declare(stop_var.clone(), Type::Int);
        self.declare(step_var.clone(), Type::Int);
        self.declare(idx_var.clone(), Type::Int);
        self.declare(target_names[0].clone(), Type::Int);
        self.declare(target_names[1].clone(), elem_ty.to_type());

        let mut body = vec![
            TirStmt::Let {
                name: target_names[0].clone(),
                ty: ValueType::Int,
                value: TirExpr {
                    kind: TirExprKind::Var(idx_var.clone()),
                    ty: ValueType::Int,
                },
            },
            TirStmt::Let {
                name: target_names[1].clone(),
                ty: elem_ty.clone(),
                value: self.make_list_get_expr(&list_var, list_expr.ty.clone(), &idx_var, elem_ty),
            },
        ];
        body.extend(self.lower_block_in_current_scope(&ast_get_list!(node, "body"))?);
        let else_body = self.lower_block_in_current_scope(&ast_get_list!(node, "orelse"))?;

        Ok(vec![
            TirStmt::Let {
                name: list_var.clone(),
                ty: list_expr.ty.clone(),
                value: list_expr.clone(),
            },
            TirStmt::Let {
                name: len_var.clone(),
                ty: ValueType::Int,
                value: TirExpr {
                    kind: TirExprKind::ExternalCall {
                        func: builtin::BuiltinFn::ListLen,
                        args: vec![TirExpr {
                            kind: TirExprKind::Var(list_var),
                            ty: list_expr.ty.clone(),
                        }],
                    },
                    ty: ValueType::Int,
                },
            },
            TirStmt::Let {
                name: start_var.clone(),
                ty: ValueType::Int,
                value: TirExpr {
                    kind: TirExprKind::IntLiteral(0),
                    ty: ValueType::Int,
                },
            },
            TirStmt::Let {
                name: stop_var.clone(),
                ty: ValueType::Int,
                value: TirExpr {
                    kind: TirExprKind::Var(len_var),
                    ty: ValueType::Int,
                },
            },
            TirStmt::Let {
                name: step_var.clone(),
                ty: ValueType::Int,
                value: TirExpr {
                    kind: TirExprKind::IntLiteral(1),
                    ty: ValueType::Int,
                },
            },
            TirStmt::ForRange {
                loop_var: idx_var,
                start_var,
                stop_var,
                step_var,
                body,
                else_body,
            },
        ])
    }

    fn handle_for_range(
        &mut self,
        node: &Bound<PyAny>,
        line: usize,
        loop_var: &str,
        iter_node: &Bound<PyAny>,
    ) -> Result<Vec<TirStmt>> {
        let args_list = ast_get_list!(iter_node, "args");
        if args_list.is_empty() || args_list.len() > 3 {
            return Err(self.type_error(
                line,
                format!("range() expects 1 to 3 arguments, got {}", args_list.len()),
            ));
        }

        let mut args = Vec::new();
        for arg in args_list.iter() {
            let expr = self.lower_expr(&arg)?;
            if expr.ty != ValueType::Int {
                return Err(self.type_error(
                    line,
                    format!("range() arguments must be `int`, got `{}`", expr.ty),
                ));
            }
            args.push(expr);
        }

        let (start_expr, stop_expr, step_expr) = match args.len() {
            1 => (
                TirExpr {
                    kind: TirExprKind::IntLiteral(0),
                    ty: ValueType::Int,
                },
                args[0].clone(),
                TirExpr {
                    kind: TirExprKind::IntLiteral(1),
                    ty: ValueType::Int,
                },
            ),
            2 => (
                args[0].clone(),
                args[1].clone(),
                TirExpr {
                    kind: TirExprKind::IntLiteral(1),
                    ty: ValueType::Int,
                },
            ),
            3 => (args[0].clone(), args[1].clone(), args[2].clone()),
            _ => unreachable!(),
        };

        let start_name = self.fresh_internal("range_start");
        let stop_name = self.fresh_internal("range_stop");
        let step_name = self.fresh_internal("range_step");

        self.declare(start_name.clone(), Type::Int);
        self.declare(stop_name.clone(), Type::Int);
        self.declare(step_name.clone(), Type::Int);
        self.declare(loop_var.to_string(), Type::Int);

        let body = self.lower_block_in_current_scope(&ast_get_list!(node, "body"))?;
        let else_body = self.lower_block_in_current_scope(&ast_get_list!(node, "orelse"))?;

        Ok(vec![
            TirStmt::Let {
                name: start_name.clone(),
                ty: ValueType::Int,
                value: start_expr,
            },
            TirStmt::Let {
                name: stop_name.clone(),
                ty: ValueType::Int,
                value: stop_expr,
            },
            TirStmt::Let {
                name: step_name.clone(),
                ty: ValueType::Int,
                value: step_expr,
            },
            TirStmt::ForRange {
                loop_var: loop_var.to_string(),
                start_var: start_name,
                stop_var: stop_name,
                step_var: step_name,
                body,
                else_body,
            },
        ])
    }

    fn handle_for_list(
        &mut self,
        node: &Bound<PyAny>,
        _line: usize,
        loop_var: &str,
        list_expr: TirExpr,
        elem_ty: ValueType,
    ) -> Result<Vec<TirStmt>> {
        let list_var = self.fresh_internal("for_list");
        let idx_var = self.fresh_internal("for_idx");
        let len_var = self.fresh_internal("for_len");

        self.declare(list_var.clone(), list_expr.ty.to_type());
        self.declare(idx_var.clone(), Type::Int);
        self.declare(len_var.clone(), Type::Int);
        self.declare(loop_var.to_string(), elem_ty.to_type());

        let body = self.lower_block_in_current_scope(&ast_get_list!(node, "body"))?;
        let else_body = self.lower_block_in_current_scope(&ast_get_list!(node, "orelse"))?;

        Ok(vec![
            TirStmt::Let {
                name: list_var.clone(),
                ty: list_expr.ty.clone(),
                value: list_expr,
            },
            TirStmt::ForList {
                loop_var: loop_var.to_string(),
                loop_var_ty: elem_ty,
                list_var,
                index_var: idx_var,
                len_var,
                body,
                else_body,
            },
        ])
    }

    fn handle_for_class_iter(
        &mut self,
        node: &Bound<PyAny>,
        line: usize,
        loop_var: &str,
        obj_expr: TirExpr,
        class_name: &str,
    ) -> Result<Vec<TirStmt>> {
        let class_info = self.lookup_class(line, class_name)?;

        // Check __iter__
        let iter_method = class_info.methods.get("__iter__").ok_or_else(|| {
            self.type_error(
                line,
                format!("class `{}` does not implement `__iter__`", class_name),
            )
        })?;
        let iter_class_name = match &iter_method.return_type {
            Type::Class(name) => name.clone(),
            _ => {
                return Err(self.type_error(
                    line,
                    format!("`{}`.__iter__() must return a class instance", class_name),
                ))
            }
        };
        let iter_mangled = iter_method.mangled_name.clone();

        // Check the iterator class has __next__
        let iter_class_info = self.lookup_class(line, &iter_class_name)?;
        let next_method = iter_class_info.methods.get("__next__").ok_or_else(|| {
            self.type_error(
                line,
                format!(
                    "iterator class `{}` does not implement `__next__`",
                    iter_class_name
                ),
            )
        })?;

        let elem_ty = Self::to_value_type(&next_method.return_type);
        let next_mangled = next_method.mangled_name.clone();

        // Create temp vars
        let obj_var = self.fresh_internal("for_obj");
        let iter_var = self.fresh_internal("for_iter");

        self.declare(obj_var.clone(), obj_expr.ty.to_type());
        self.declare(iter_var.clone(), Type::Class(iter_class_name.clone()));
        self.declare(loop_var.to_string(), next_method.return_type.clone());

        let body = self.lower_block_in_current_scope(&ast_get_list!(node, "body"))?;
        let else_body = self.lower_block_in_current_scope(&ast_get_list!(node, "orelse"))?;

        Ok(vec![
            TirStmt::Let {
                name: obj_var.clone(),
                ty: obj_expr.ty.clone(),
                value: obj_expr.clone(),
            },
            TirStmt::Let {
                name: iter_var.clone(),
                ty: ValueType::Class(iter_class_name.clone()),
                value: TirExpr {
                    kind: TirExprKind::Call {
                        func: iter_mangled,
                        args: vec![TirExpr {
                            kind: TirExprKind::Var(obj_var),
                            ty: obj_expr.ty,
                        }],
                    },
                    ty: ValueType::Class(iter_class_name.clone()),
                },
            },
            TirStmt::ForIter {
                loop_var: loop_var.to_string(),
                loop_var_ty: elem_ty,
                iterator_var: iter_var,
                iterator_class: iter_class_name,
                next_mangled,
                body,
                else_body,
            },
        ])
    }

    fn handle_for_tuple(
        &mut self,
        node: &Bound<PyAny>,
        _line: usize,
        loop_var: &str,
        tuple_expr: TirExpr,
        elem_ty: ValueType,
        tuple_len: usize,
    ) -> Result<Vec<TirStmt>> {
        // Lower as: for __idx in range(0, len):  loop_var = tuple[__idx]
        let tuple_var = self.fresh_internal("for_tuple");
        let start_name = self.fresh_internal("range_start");
        let stop_name = self.fresh_internal("range_stop");
        let step_name = self.fresh_internal("range_step");
        let idx_var = self.fresh_internal("for_tuple_idx");

        self.declare(tuple_var.clone(), tuple_expr.ty.to_type());
        self.declare(start_name.clone(), Type::Int);
        self.declare(stop_name.clone(), Type::Int);
        self.declare(step_name.clone(), Type::Int);
        self.declare(idx_var.clone(), Type::Int);
        self.declare(loop_var.to_string(), elem_ty.to_type());

        let body = self.lower_block_in_current_scope(&ast_get_list!(node, "body"))?;
        let else_body = self.lower_block_in_current_scope(&ast_get_list!(node, "orelse"))?;

        // Prepend: loop_var = tuple[idx_var]
        let mut full_body = vec![TirStmt::Let {
            name: loop_var.to_string(),
            ty: elem_ty.clone(),
            value: TirExpr {
                kind: TirExprKind::ExternalCall {
                    func: builtin::BuiltinFn::TupleGetItem,
                    args: vec![
                        TirExpr {
                            kind: TirExprKind::Var(tuple_var.clone()),
                            ty: tuple_expr.ty.clone(),
                        },
                        TirExpr {
                            kind: TirExprKind::Var(idx_var.clone()),
                            ty: ValueType::Int,
                        },
                    ],
                },
                ty: elem_ty,
            },
        }];
        full_body.extend(body);

        Ok(vec![
            TirStmt::Let {
                name: tuple_var,
                ty: tuple_expr.ty.clone(),
                value: tuple_expr,
            },
            TirStmt::Let {
                name: start_name.clone(),
                ty: ValueType::Int,
                value: TirExpr {
                    kind: TirExprKind::IntLiteral(0),
                    ty: ValueType::Int,
                },
            },
            TirStmt::Let {
                name: stop_name.clone(),
                ty: ValueType::Int,
                value: TirExpr {
                    kind: TirExprKind::IntLiteral(tuple_len as i64),
                    ty: ValueType::Int,
                },
            },
            TirStmt::Let {
                name: step_name.clone(),
                ty: ValueType::Int,
                value: TirExpr {
                    kind: TirExprKind::IntLiteral(1),
                    ty: ValueType::Int,
                },
            },
            TirStmt::ForRange {
                loop_var: idx_var,
                start_var: start_name,
                stop_var: stop_name,
                step_var: step_name,
                body: full_body,
                else_body,
            },
        ])
    }

    fn handle_for_str(
        &mut self,
        node: &Bound<PyAny>,
        _line: usize,
        loop_var: &str,
        str_expr: TirExpr,
    ) -> Result<Vec<TirStmt>> {
        let str_var = self.fresh_internal("for_str");
        let idx_var = self.fresh_internal("for_str_idx");
        let len_var = self.fresh_internal("for_str_len");

        self.declare(str_var.clone(), str_expr.ty.to_type());
        self.declare(idx_var.clone(), Type::Int);
        self.declare(len_var.clone(), Type::Int);
        self.declare(loop_var.to_string(), Type::Str);

        let body = self.lower_block_in_current_scope(&ast_get_list!(node, "body"))?;
        let else_body = self.lower_block_in_current_scope(&ast_get_list!(node, "orelse"))?;

        Ok(vec![
            TirStmt::Let {
                name: str_var.clone(),
                ty: str_expr.ty.clone(),
                value: str_expr,
            },
            TirStmt::ForStr {
                loop_var: loop_var.to_string(),
                str_var,
                index_var: idx_var,
                len_var,
                body,
                else_body,
            },
        ])
    }

    fn handle_for_bytes(
        &mut self,
        node: &Bound<PyAny>,
        _line: usize,
        loop_var: &str,
        bytes_expr: TirExpr,
    ) -> Result<Vec<TirStmt>> {
        let bytes_var = self.fresh_internal("for_bytes");
        let idx_var = self.fresh_internal("for_bytes_idx");
        let len_var = self.fresh_internal("for_bytes_len");

        self.declare(bytes_var.clone(), bytes_expr.ty.to_type());
        self.declare(idx_var.clone(), Type::Int);
        self.declare(len_var.clone(), Type::Int);
        self.declare(loop_var.to_string(), Type::Int);

        let body = self.lower_block_in_current_scope(&ast_get_list!(node, "body"))?;
        let else_body = self.lower_block_in_current_scope(&ast_get_list!(node, "orelse"))?;

        Ok(vec![
            TirStmt::Let {
                name: bytes_var.clone(),
                ty: bytes_expr.ty.clone(),
                value: bytes_expr,
            },
            TirStmt::ForBytes {
                loop_var: loop_var.to_string(),
                bytes_var,
                index_var: idx_var,
                len_var,
                body,
                else_body,
            },
        ])
    }

    fn handle_for_bytearray(
        &mut self,
        node: &Bound<PyAny>,
        _line: usize,
        loop_var: &str,
        bytearray_expr: TirExpr,
    ) -> Result<Vec<TirStmt>> {
        let bytearray_var = self.fresh_internal("for_bytearray");
        let idx_var = self.fresh_internal("for_bytearray_idx");
        let len_var = self.fresh_internal("for_bytearray_len");

        self.declare(bytearray_var.clone(), bytearray_expr.ty.to_type());
        self.declare(idx_var.clone(), Type::Int);
        self.declare(len_var.clone(), Type::Int);
        self.declare(loop_var.to_string(), Type::Int);

        let body = self.lower_block_in_current_scope(&ast_get_list!(node, "body"))?;
        let else_body = self.lower_block_in_current_scope(&ast_get_list!(node, "orelse"))?;

        Ok(vec![
            TirStmt::Let {
                name: bytearray_var.clone(),
                ty: bytearray_expr.ty.clone(),
                value: bytearray_expr,
            },
            TirStmt::ForByteArray {
                loop_var: loop_var.to_string(),
                bytearray_var,
                index_var: idx_var,
                len_var,
                body,
                else_body,
            },
        ])
    }

    //  exception handling 

    fn handle_raise(&mut self, node: &Bound<PyAny>, line: usize) -> Result<Vec<TirStmt>> {
        let exc_node = ast_getattr!(node, "exc");
        if exc_node.is_none() {
            return Ok(vec![TirStmt::Raise {
                exc_type_tag: None,
                message: None,
            }]);
        }

        match ast_type_name!(exc_node).as_str() {
            "Call" => {
                let func_node = ast_getattr!(exc_node, "func");
                let exc_name = if ast_type_name!(func_node) == "Name" {
                    ast_get_string!(func_node, "id")
                } else {
                    return Err(self.syntax_error(line, "unsupported raise expression"));
                };

                let type_tag = Self::resolve_exception_tag(&exc_name).ok_or_else(|| {
                    self.syntax_error(line, format!("unsupported exception type `{}`", exc_name))
                })?;

                let args_list = ast_get_list!(exc_node, "args");
                let message = if args_list.is_empty() {
                    None
                } else if args_list.len() == 1 {
                    let msg_expr = self.lower_expr(&args_list.get_item(0)?)?;
                    if msg_expr.ty != ValueType::Str {
                        return Err(self.type_error(
                            line,
                            format!("exception message must be `str`, got `{}`", msg_expr.ty),
                        ));
                    }
                    Some(msg_expr)
                } else {
                    return Err(
                        self.syntax_error(line, format!("{}() takes 0 or 1 arguments", exc_name))
                    );
                };

                Ok(vec![TirStmt::Raise {
                    exc_type_tag: Some(type_tag),
                    message,
                }])
            }
            "Name" => {
                let exc_name = ast_get_string!(exc_node, "id");
                let type_tag = Self::resolve_exception_tag(&exc_name).ok_or_else(|| {
                    self.syntax_error(line, format!("unsupported exception type `{}`", exc_name))
                })?;
                Ok(vec![TirStmt::Raise {
                    exc_type_tag: Some(type_tag),
                    message: None,
                }])
            }
            _ => Err(self.syntax_error(line, "unsupported raise expression")),
        }
    }

    fn resolve_exception_tag(name: &str) -> Option<i64> {
        match name {
            "Exception" => Some(1),
            "StopIteration" => Some(2),
            "ValueError" => Some(3),
            "TypeError" => Some(4),
            "KeyError" => Some(5),
            "RuntimeError" => Some(6),
            "ZeroDivisionError" => Some(7),
            "OverflowError" => Some(8),
            "IndexError" => Some(9),
            "AttributeError" => Some(10),
            "NotImplementedError" => Some(11),
            "NameError" => Some(12),
            "ArithmeticError" => Some(13),
            "LookupError" => Some(14),
            "AssertionError" => Some(15),
            "ImportError" => Some(16),
            "ModuleNotFoundError" => Some(17),
            "FileNotFoundError" => Some(18),
            "PermissionError" => Some(19),
            "OSError" | "IOError" => Some(20),
            _ => None,
        }
    }

    fn handle_try(&mut self, node: &Bound<PyAny>, line: usize) -> Result<Vec<TirStmt>> {
        let finalbody = ast_get_list!(node, "finalbody");
        let has_finally = !finalbody.is_empty();

        // `return` is forbidden inside try/except/finally blocks that have
        // a finally clause, because the codegen cannot guarantee the finally
        // block runs before the function exits.
        if has_finally {
            self.in_try_finally_depth += 1;
        }

        let try_body = self.lower_block(&ast_get_list!(node, "body"))?;

        let handlers_list = ast_get_list!(node, "handlers");
        let mut except_clauses = Vec::new();
        for handler in handlers_list.iter() {
            let type_node = ast_getattr!(handler, "type");
            let exc_type_tag = if type_node.is_none() {
                None // bare except
            } else {
                let type_name = if ast_type_name!(type_node) == "Name" {
                    ast_get_string!(type_node, "id")
                } else {
                    return Err(
                        self.syntax_error(line, "unsupported exception type in except clause")
                    );
                };
                Some(Self::resolve_exception_tag(&type_name).ok_or_else(|| {
                    self.syntax_error(line, format!("unsupported exception type `{}`", type_name))
                })?)
            };

            let name_node = ast_getattr!(handler, "name");
            let var_name = if name_node.is_none() {
                None
            } else {
                let name = name_node.extract::<String>()?;
                // Declare the exception variable as str in the handler scope
                self.declare(name.clone(), Type::Str);
                Some(name)
            };

            let handler_body = self.lower_block(&ast_get_list!(handler, "body"))?;
            except_clauses.push(ExceptClause {
                exc_type_tag,
                var_name,
                body: handler_body,
            });
        }

        let orelse = ast_get_list!(node, "orelse");
        let else_body = if orelse.is_empty() {
            vec![]
        } else {
            self.lower_block(&orelse)?
        };

        let finally_body = if finalbody.is_empty() {
            vec![]
        } else {
            self.lower_block(&finalbody)?
        };

        if has_finally {
            self.in_try_finally_depth -= 1;
        }

        Ok(vec![TirStmt::TryCatch {
            try_body,
            except_clauses,
            else_body,
            finally_body,
            has_finally,
        }])
    }

    //  attribute assignment 

    fn lower_attribute_assign(
        &mut self,
        target_node: &Bound<PyAny>,
        assign_node: &Bound<PyAny>,
        line: usize,
    ) -> Result<Vec<TirStmt>> {
        let obj_node = ast_getattr!(target_node, "value");
        let field_name = ast_get_string!(target_node, "attr");
        let obj_expr = self.lower_expr(&obj_node)?;

        let class_name = match &obj_expr.ty {
            ValueType::Class(name) => name.clone(),
            other => {
                return Err(self.type_error(
                    line,
                    format!("cannot set attribute on non-class type `{}`", other),
                ))
            }
        };

        let class_info = self.lookup_class(line, &class_name)?;
        let field_index = self.lookup_field_index(line, &class_info, &field_name)?;
        let field = &class_info.fields[field_index];

        // Enforce reference-type field immutability outside __init__
        if field.ty.is_reference_type() {
            let inside_init = self.current_class.as_ref() == Some(&class_name)
                && self
                    .current_function_name
                    .as_ref()
                    .map(|n| n.ends_with(".__init__"))
                    .unwrap_or(false);
            let is_self = matches!(&obj_expr.kind, TirExprKind::Var(name) if name == "self");

            if !(inside_init && is_self) {
                return Err(self.type_error(
                    line,
                    format!(
                        "cannot reassign reference field `{}.{}` of type `{}` outside of __init__",
                        class_name, field_name, field.ty
                    ),
                ));
            }
        }

        let value_node = ast_getattr!(assign_node, "value");

        // Handle empty list/dict literals using the field's type annotation
        let tir_value = if ast_type_name!(value_node) == "List" {
            let elts = ast_get_list!(value_node, "elts");
            if elts.is_empty() {
                let inner_ty = match &field.ty {
                    Type::List(inner) => Self::to_value_type(inner),
                    _ => {
                        return Err(self.type_error(
                            line,
                            format!(
                                "cannot assign empty list `[]` to field `{}.{}` of type `{}`",
                                class_name, field_name, field.ty
                            ),
                        ))
                    }
                };
                let vty = ValueType::List(Box::new(inner_ty.clone()));
                TirExpr {
                    kind: TirExprKind::ListLiteral {
                        element_type: inner_ty,
                        elements: vec![],
                    },
                    ty: vty,
                }
            } else {
                self.lower_expr(&value_node)?
            }
        } else if ast_type_name!(value_node) == "Dict" {
            let keys = ast_get_list!(value_node, "keys");
            if keys.is_empty() {
                let (key_ty, value_ty) = match &field.ty {
                    Type::Dict(key, value) => {
                        (Self::to_value_type(key), Self::to_value_type(value))
                    }
                    _ => {
                        return Err(self.type_error(
                            line,
                            format!(
                                "cannot assign empty dict `{{}}` to field `{}.{}` of type `{}`",
                                class_name, field_name, field.ty
                            ),
                        ))
                    }
                };
                let vty = ValueType::Dict(Box::new(key_ty), Box::new(value_ty));
                TirExpr {
                    kind: TirExprKind::ExternalCall {
                        func: builtin::BuiltinFn::DictEmpty,
                        args: vec![],
                    },
                    ty: vty,
                }
            } else {
                self.lower_expr(&value_node)?
            }
        } else {
            self.lower_expr(&value_node)?
        };

        if tir_value.ty.to_type() != field.ty {
            return Err(self.type_error(
                line,
                format!(
                    "cannot assign `{}` to field `{}.{}` of type `{}`",
                    tir_value.ty, class_name, field_name, field.ty
                ),
            ));
        }

        Ok(vec![TirStmt::SetField {
            object: obj_expr,
            class_name,
            field_index,
            value: tir_value,
        }])
    }

    //  subscript assignment 

    fn lower_subscript_assign(
        &mut self,
        target_node: &Bound<PyAny>,
        assign_node: &Bound<PyAny>,
        line: usize,
    ) -> Result<Vec<TirStmt>> {
        let value_node_target = ast_getattr!(target_node, "value");
        let slice_node = ast_getattr!(target_node, "slice");
        let value_node = ast_getattr!(assign_node, "value");

        let list_expr = self.lower_expr(&value_node_target)?;
        match &list_expr.ty {
            ValueType::List(inner) => {
                let index_expr = self.lower_expr(&slice_node)?;
                if index_expr.ty != ValueType::Int {
                    return Err(self.type_error(
                        line,
                        format!("list index must be `int`, got `{}`", index_expr.ty),
                    ));
                }
                let tir_value = self.lower_expr(&value_node)?;
                let expected_elem_ty = inner.as_ref();
                if &tir_value.ty != expected_elem_ty {
                    return Err(self.type_error(
                        line,
                        format!(
                            "cannot assign `{}` to element of `list[{}]`",
                            tir_value.ty, expected_elem_ty
                        ),
                    ));
                }
                Ok(vec![TirStmt::ListSet {
                    list: list_expr,
                    index: index_expr,
                    value: tir_value,
                }])
            }
            ValueType::Dict(key_ty, value_ty) => {
                let key_expr = self.lower_expr(&slice_node)?;
                if key_expr.ty != **key_ty {
                    return Err(self.type_error(
                        line,
                        format!("dict key index must be `{}`, got `{}`", key_ty, key_expr.ty),
                    ));
                }
                let tir_value = self.lower_expr(&value_node)?;
                if tir_value.ty != **value_ty {
                    return Err(self.type_error(
                        line,
                        format!(
                            "cannot assign `{}` to value of `dict[{}, {}]`",
                            tir_value.ty, key_ty, value_ty
                        ),
                    ));
                }
                Ok(vec![TirStmt::VoidCall {
                    target: CallTarget::Builtin(builtin::BuiltinFn::DictSet),
                    args: vec![list_expr, key_expr, tir_value],
                }])
            }
            ValueType::Tuple(_) => {
                Err(self.type_error(line, "tuple does not support index assignment".to_string()))
            }
            other => Err(self.type_error(
                line,
                format!("type `{}` does not support index assignment", other),
            )),
        }
    }

    fn lower_subscript_aug_assign(
        &mut self,
        target_node: &Bound<PyAny>,
        aug_node: &Bound<PyAny>,
        line: usize,
    ) -> Result<Vec<TirStmt>> {
        let value_node = ast_getattr!(target_node, "value");
        let slice_node = ast_getattr!(target_node, "slice");

        let list_expr = self.lower_expr(&value_node)?;
        match &list_expr.ty {
            ValueType::List(inner) => {
                let index_expr = self.lower_expr(&slice_node)?;
                if index_expr.ty != ValueType::Int {
                    return Err(self.type_error(
                        line,
                        format!("list index must be `int`, got `{}`", index_expr.ty),
                    ));
                }
                let elem_ty = inner.as_ref().clone();

                let current_val = TirExpr {
                    kind: TirExprKind::ExternalCall {
                        func: builtin::BuiltinFn::ListGet,
                        args: vec![list_expr.clone(), index_expr.clone()],
                    },
                    ty: elem_ty,
                };

                let op = Self::convert_binop(&ast_getattr!(aug_node, "op"))?;
                let rhs = self.lower_expr(&ast_getattr!(aug_node, "value"))?;
                let binop_expr = self.resolve_binop(line, op, current_val, rhs)?;

                if &binop_expr.ty != inner.as_ref() {
                    return Err(self.type_error(
                        line,
                        format!(
                            "augmented assignment would change list element type from `{}` to `{}`",
                            inner, binop_expr.ty
                        ),
                    ));
                }

                Ok(vec![TirStmt::ListSet {
                    list: list_expr,
                    index: index_expr,
                    value: binop_expr,
                }])
            }
            ValueType::Dict(key_ty, value_ty) => {
                let key_expr = self.lower_expr(&slice_node)?;
                if key_expr.ty != **key_ty {
                    return Err(self.type_error(
                        line,
                        format!("dict key index must be `{}`, got `{}`", key_ty, key_expr.ty),
                    ));
                }

                let current_val = TirExpr {
                    kind: TirExprKind::ExternalCall {
                        func: builtin::BuiltinFn::DictGet,
                        args: vec![list_expr.clone(), key_expr.clone()],
                    },
                    ty: (**value_ty).clone(),
                };

                let op = Self::convert_binop(&ast_getattr!(aug_node, "op"))?;
                let rhs = self.lower_expr(&ast_getattr!(aug_node, "value"))?;
                let binop_expr = self.resolve_binop(line, op, current_val, rhs)?;

                if binop_expr.ty != **value_ty {
                    return Err(self.type_error(
                        line,
                        format!(
                            "augmented assignment would change dict value type from `{}` to `{}`",
                            value_ty, binop_expr.ty
                        ),
                    ));
                }

                Ok(vec![TirStmt::VoidCall {
                    target: CallTarget::Builtin(builtin::BuiltinFn::DictSet),
                    args: vec![list_expr, key_expr, binop_expr],
                }])
            }
            ValueType::Tuple(_) => {
                Err(self.type_error(line, "tuple does not support index assignment".to_string()))
            }
            other => Err(self.type_error(
                line,
                format!("type `{}` does not support index assignment", other),
            )),
        }
    }

    fn lower_attribute_aug_assign(
        &mut self,
        target_node: &Bound<PyAny>,
        aug_node: &Bound<PyAny>,
        line: usize,
    ) -> Result<Vec<TirStmt>> {
        let obj_node = ast_getattr!(target_node, "value");
        let field_name = ast_get_string!(target_node, "attr");
        let obj_expr = self.lower_expr(&obj_node)?;

        let class_name = match &obj_expr.ty {
            ValueType::Class(name) => name.clone(),
            other => {
                return Err(self.type_error(
                    line,
                    format!("cannot set attribute on non-class type `{}`", other),
                ))
            }
        };

        let class_info = self.lookup_class(line, &class_name)?;
        let field_index = self.lookup_field_index(line, &class_info, &field_name)?;
        let field = &class_info.fields[field_index];
        let field_vty = Self::to_value_type(&field.ty);

        // Read current field value
        let current_val = TirExpr {
            kind: TirExprKind::GetField {
                object: Box::new(obj_expr.clone()),
                class_name: class_name.clone(),
                field_index,
            },
            ty: field_vty,
        };

        let op = Self::convert_binop(&ast_getattr!(aug_node, "op"))?;
        let rhs = self.lower_expr(&ast_getattr!(aug_node, "value"))?;

        let binop_expr = self.resolve_binop(line, op, current_val, rhs)?;

        if binop_expr.ty.to_type() != field.ty {
            return Err(self.type_error(
                line,
                format!(
                    "augmented assignment would change field `{}.{}` type from `{}` to `{}`",
                    class_name, field_name, field.ty, binop_expr.ty
                ),
            ));
        }

        Ok(vec![TirStmt::SetField {
            object: obj_expr,
            class_name,
            field_index,
            value: binop_expr,
        }])
    }
}
